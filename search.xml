<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Java基础]]></title>
    <url>%2F2019%2F08%2F28%2FJava%20%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[Java 基础异常类异常说明如果出错，创建出一个异常类对象，抛出相关信息 继承关系1234Throwable | - Error java内部错误 不会捕获异常 （内部错误） | - Exception | - RuntimeExecption 运行异常 运行阶段 nullpoint | - CheckedException 检查异常 编译阶段 （外部错误） 文件 url IOException等 Throw &amp; Throws 位置不同 throw 是跟着异常对象 用在函数内 throws 跟着异常类 用在函数上 12throw new NumberFormateException();int div(int a, int b ) throws Exception&#123;&#125; 功能性 告知 throws 告知可能会抛出异常 throw 某部分执行到throw一定抛出具体异常对象 且功能结束，告知异常 消极处理 真正处理的是 函数的上级调用者 即：抛出 而不是用try catch 捕获 Finallytry中执行到return语句，不会直接return， 先计算return表达式，把结果保存到临时栈，再执行finally语句，之后才把临时栈的结果返回。 Java容器容器模型 12 ### 装箱&amp;拆箱int 与 integer区别： 数据类型与包装类区别 int：直接存数值 （初始化 = 0） integer：引用指向这个对象（初始值 null） integer a =1; -&gt; integer a = integer.valueOf(1); JavaI/O流字符流String 、StringBuild、 StringBuffer区别 Java并发线程内存模型 特点： 每个线程需要从主内存中 获取 变量的值 获取数据之后回放入自己的工作内存中，都是主内存拷贝的副本 线程间无法直接访问对方工作内存 线程工作状态 lock（锁定）：在某一个线程在读取主内存的时候需要把变量锁定。 unlock（解锁）：某一个线程读取玩变量值之后会释放锁定，别的线程就可以进入操作 。 read（读取）：从主内存中读取变量的值并放入工作内存中 。 load（加载）：从read操作得到的值放入工作内存变量副本中 。 use（使用）：把工作内存中的一个变量值传递给执行引擎 。 assign（赋值）：它把一个从执行引擎接收到的值赋值给工作内存的变量 。 store（存储）：把工作内存中的一个变量的值传送到主内存中 。 write（写入）：把store操作从工作内存中一个变量的值传送到主内存的变量中。 线程内部方法 单线程123456789101112131415161718public class one extends Thread&#123; public void run()&#123;........&#125;;&#125;///////////////////2////////////public class two implements Runnable&#123; public void run()&#123;......&#125;;&#125;/////////////3//////////内部////////new Thread(new Runnable()&#123; public void run()&#123; sout("sdfs") ; &#125;&#125;);new Thread(()-&gt;&#123; sout("sdfs") ;&#125;);///////////one a = new one();two b = new two();a.start(), b.start(); #### 多线程使用线程池利用线程池管理线程的创建销毁，【缓存功能】 降低资源消耗 提高响应速度 线程可管理 常用线程池 CacheThreadPool 无界 SynchronizedQueue 无缓存队列 接收任务直接处理 FixedThreadPool 有界 LinkedBlokingQueue 列表阻塞队列 无界队列可缓存 读写分离 SingleThreadPool 单一 LinkedBlokingQueue 指定队列 1 ScheduledThreadPoll 定时周期 CachedThreadPool 无界线程池 1234567891011121314public class CachedThreadPoolTest&#123; psvm&#123; ExecutorService exec = Executors.newCachedThreadPool(); for(20 times) &#123; exec.execute(new WorkTask()); &#125; exec.shutdown(); &#125;&#125;//构造方法 参数 （线程数 最大线程数 时间片 单位时间 阻塞队列）public static ExecutorService newCachedThreadPool()&#123; return new ThreadpoolExecutor(0,Integer.MAX_VALUE,60L,TimeUnit.SECONDS,new Sysnchronous&lt;Runnable&gt;());&#125; FixedThreadPool 有界线程池 1234567891011121314public class FixedThreadPoolTest&#123; psvm&#123; ExecutorService exec = Executors.newFixedThreadPool(3); for(20 times) &#123; exec.execute(new WorkTask()); &#125; exec.shutdown(); &#125;&#125;public static ExecutorService newFixedThreadPool(int nThreads)&#123; return new ThreadPoolExecutor(nThreads, nThreads,0L, TimeUnit.MILLISECONDS,new LinkedBlockingQueue&lt;Runnable&gt;());&#125; SingleThreadExecutor 单一线程池 12345678910111213public class SingleThreadPoolTest&#123; psvm&#123; ExecutorService exec = Executors.newSingleTheadExecutor(); for(20 times) &#123; exec.execute(new WorkTask()); &#125; exec.shutdown(); &#125;&#125;public static ExecutorService newSingleThreadExecutor() &#123; return new FinalizableDelegatedExecutorService (new ThreadPoolExecutor(1, 1,0L, TimeUnit.MILLISECONDS,new LinkedBlockingQueue&lt;Runnable&gt;())); ScheduledThreadPool 定时周期 1234567public class ScheduledThreadPool&#123; psvm&#123; ExectorService exec = new Exector.newScheduledThreadExecutor(3); exec.execute(new WorkTask()); exec.shutdown(); &#125;&#125; 线程生命周期 新建 new创建线程 -&gt; JVM分配内存 &amp; 初始化成员变量的值。 就绪 线程对象调用start() 创建方法调用栈 &amp; 程序计数器 等待调度运行。 运行 处于就绪状态线程获得CPU，开始执行run（）方法的线程执行体。 阻塞 等待阻塞 run线程 执行 o.wait() jvm 会把线程放进等待队列 同步阻塞 run线程 想获取对象的同步锁，该锁被别的线程占用，jvm把线程放入锁池中（lock pool） 其他阻塞 Thread.sleep || t.join() || 发出IO请求 死亡 正常结束 run() || call() 方法执行完成 异常结束 线程抛出异常 调用stop stop() 乐观锁 &amp; 悲观锁 容器并发CopyOnWrite容器当我们向容器中添加元素，先copy该容器，把数据添加到copy容器中，再将数组引用指向容器。 实现线程安全： volatile修饰数组引用：确保数组内存可见性。【内存可见】-》 copy数组引用。 对容器修改操作同步。同一时刻只有一条线程修改容器 修改容器复制容器：修改操作都在新数组上，原数组可以放心读。 优点 并发读，实现读写分离 （当前容器不会添加任何元素） 无需加锁 缺点 内存占用，使用两个容器 只能保证数据最终一致性，无法保证实时性 使用场景读多写少，且不要求实时性 ConcurrentHashMap线程安全的HashTable改进版（一个线程访问，其他统统阻塞），而ConcurrentHashMap实现分段锁机制。 分段锁原理ConcurrentHashMap由多个Segment构成，每个Segment都包含一张哈希表。每次操作只将操作数据所属的Segment锁起来，从而避免将整个锁住。 每个Segment守护一个HashEntry数组的元素，当对hashEntry数组数据修改是，必须先获取对应的Segment锁（就是分段锁机制） ConcurrentHashMap内部包含了Segment数组，而每个Segment又继承自ReentrantLock，因此它是一把可重入的锁。]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剑指office算法]]></title>
    <url>%2F2019%2F08%2F27%2Foffice%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[不修改数组找出重复的数字123456789101112131415161718192021222324/**给定一个长度为 n+1 的数组nums，数组中所有的数均在 1∼n 的范围内，其中 n≥1。请找出数组中任意一个重复的数，但不能修改输入的数组。样例给定 nums = [2, 3, 5, 4, 3, 2, 6, 7]。返回 2 或 3。*/class Solution &#123;public: int duplicateInArray(vector&lt;int&gt;&amp; nums) &#123; int l = 1, r = nums.size() -1; while(l &lt; r)&#123; int mid = r + l &gt;&gt; 1; int s = 0; for(auto x : nums) s += x &gt;=l &amp;&amp; x &lt;= r; if(s &gt; mid - l + 1) r = mid; else l = mid + 1; &#125; return r; &#125;&#125;; 重建二叉树12345678910111213141516171819202122232425262728293031323334353637383940/**给定：前序遍历是：[3, 9, 20, 15, 7]中序遍历是：[9, 3, 15, 20, 7]返回：[3, 9, 20, null, null, 15, 7, null, null, null, null]返回的二叉树如下所示： 3 / \ 9 20 / \ 15 7 * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: map&lt;int,int&gt; hash; vector&lt;int&gt; preorder, inorder; TreeNode* buildTree(vector&lt;int&gt;&amp; _preorder, vector&lt;int&gt;&amp; _inorder) &#123; preorder = _preorder, inorder = _inorder; for(int i = 0; i &lt; inorder.size(); i++) hash[inorder[i]] = i; return dfs(0,preorder.size() -1,0,inorder.size() -1); TreeNode* dfs(int pl,int pr,int il, int ir)&#123; if(pl &gt; pr) return nullptr; int k = hash[root -&gt; val]; auto left = dfs(pl+1, pl + k -il, il, k -1); auto right = dfs(pl+ k -il +1, pr, k + 1, ir); root-&gt;left = left, root-&gt;right = right; return root; &#125; &#125;&#125;; 二叉树的下一个节点123456789101112131415161718192021222324252627282930313233343536373839404142/**给定一棵二叉树的其中一个节点，请找出中序遍历序列的下一个节点。注意：如果给定的节点是中序遍历序列的最后一个，则返回空节点;二叉树一定不为空，且给定的节点一定不是空节点；样例假定二叉树是：[2, 1, 3, null, null, null, null]， 给出的是值等于2的节点。则应返回值等于3的节点。解释：该二叉树的结构如下，2的后继节点是3。 2 / \1 3*//** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode *father; * TreeNode(int x) : val(x), left(NULL), right(NULL), father(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: TreeNode* inorderSuccessor(TreeNode* p) &#123; if( p -&gt; right) &#123; while(p -&gt; left) p = p -&gt; left; return p; &#125; while( p -&gt; father &amp;&amp; p == p -&gt; father -&gt; right) p = p -&gt; father; return p -&gt; father; &#125;&#125;; ## 用两个栈实现队列123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354class MyQueue &#123;public: stack&lt;int&gt; stk,cache; /** Initialize your data structure here. */ MyQueue() &#123; &#125; /** Push element x to the back of queue. */ void push(int x) &#123; stk.push(x); &#125; void copy(stack&lt;int&gt; a, stack&lt;int&gt;b)&#123; while(a.size())&#123; b.push(a.top()); a.pop(); &#125; &#125; /** Removes the element from in front of queue and returns that element. */ int pop() &#123; copy(stk,cache); int result = cache.top(); cache.pop(); copy(cache,stk); return result; &#125; /** Get the front element. */ int peek() &#123; copy(stk,cache); int result = cache.top(); copy(cache,stk); return result; &#125; /** Returns whether the queue is empty. */ bool empty() &#123; return stk.empty(); &#125;&#125;;/** * Your MyQueue object will be instantiated and called as such: * MyQueue obj = MyQueue(); * obj.push(x); * int param_2 = obj.pop(); * int param_3 = obj.peek(); * bool param_4 = obj.empty(); */ 斐波那契数列问题1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950/**定义 a0=1a0=1, a1=1a1=1, an=an−1+an−2an=an−1+an−2，求 anan 是多少。为了避免考虑整数溢出问题，我们求 an%pan%p 的值，p=109+7p=109+7。*/const int MOD = 1000000007;// 1.递归int f(int n)&#123; if(n &lt;= 1) return 1; return (f(n-1) + f(n-2)) % MOD;&#125;//2.记忆化搜索//开一个大数组记录中间结果 如果状态被计算过，直接查表，否则递归计算 //递归计算，递归层数太多会爆栈const int N = 100000, MOD = 1000000007;int a[N];if f2(int n)&#123; if(a[n]) return a[n]; if(n &lt;= 1) return 1; a[n] = f2(n - 1) + f2(n - 2); a[n] %= MOD; return a[n];&#125;//3.递推//开个大数组，记录每个数的值，用循环递推计算，//计算n个状态 则开一个长度是 n 的数组，内存将成为瓶颈const int N = 100000, MOD = 1000000007;int f3(int n)&#123; a[0] = a[1] = 1; for(int i = 2; i &lt;= n; i++) &#123; a[i] = a[i -1] + a[i - 2]; a[i] %= MOD; &#125; return a[n];&#125;//4.递归+滚动变量//递推优化 记录前两项值 时间复杂度o(n) 变成 空间复杂度变成0（1）const int MOD = 1000000007;int f4(int n)&#123; int x,y,z; x = y = 1; for(int i = 2; i &lt;= n; i++)&#123; z = (x + y) % MOD; x = y; y = z; &#125;&#125; 最后一种使用矩阵运算+快速幂 快速幂模板$$m^k\pmod p$$ 1234567891011//下次分析//时间复杂度 O(logk)。int qmi(int m, int k, int p)&#123; int res = 1 %p, t = m; while(k)&#123; if(k&amp;1) res = res * t %p; t = t * t % p; k &gt;&gt;=1; &#125;&#125; 旋转数组的最小数字1234567891011/**把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。输入一个升序的数组的一个旋转，输出旋转数组的最小元素。例如数组&#123;3,4,5,1,2&#125;为&#123;1,2,3,4,5&#125;的一个旋转，该数组的最小值为1。数组可能包含重复项。注意：数组内所含元素非负，若数组大小为0，请返回-1。样例输入：nums=[2,2,2,0,1]输出：0*/ 数组中只出现一次的数字O123456789101112131415161718192021/**数组中数字均有重复，只有两个数分别都唯一，找出这两个数输入:[2,5,2,7,3,2,3]输出:[5,7]思路： 数组所有数异或之后，[异或 同：0 不同：1]剩下两个数， 此时 5 7 0101 异或 0111 = 0010 用0001 和 0010 异或 如果不为1 ，0001 左移一位，步长++(jud &lt;&lt; 1); 之后就把 0101 和 0111 区分开来 if(jud ^ nums) x ^= nums; else y ^= nums;*/class Solution &#123;public: int singleNumber(vector&lt;int&gt;&amp; nums) &#123; int res = 0; for(auto x : nums) res ^= x; return res; &#125;&#125;; 数组中只出现一次的数字I123456789101112131415161718/** 136给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。说明：你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？示例 1:输入: [2,2,1]输出: 1示例 2:输入: [4,1,2,1,2]输出: 4思路： 每个数相互异或 得到的那个数就是只出现一次的数*/class Solution &#123;public: int singleNumber(vector&lt;int&gt;&amp; nums) &#123; &#125;&#125;; 数组中只出现一次的数字II1234567891011121314151617181920212223242526272829303132/** 137给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现了三次。找出那个只出现了一次的元素。说明：你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？示例 1:输入: [2,2,3,2]输出: 3示例 2:输入: [0,1,0,1,0,1,99]输出: 99思路： [ 0010, 0010, 0011, 0010 ]右移0位[ xxx0, xxx0, xxx1, xxx0 ]异或[ 0001 ] = [ 0, 0, 1, 0 ] =&gt;sum= 1 ;cout += sum % 3 = 1;右移1位[ xxx1, xxx1, xxx1, xxx1 ]异或[ 0001 ] = [ 1, 1, 1, 1 ] =&gt;sum= 4 ;cout += sum % 3 = 1+ sum = 2;右移2位[ xxx0, xxx0, xxx0, xxx0 ]异或[ 0000 ] = [ 0, 0, 0, 0 ] =&gt;sum= 0 ;cout += sum % 3 = 0+ sum = 2;右移3位[ xxx0, xxx0, xxx0, xxx0 ]异或[ 0000 ] = [ 0, 0, 0, 0 ] =&gt;sum= 0 ;cout += sum % 3 = 0+ sum = 2;输入为 0001左移0位 + 0001左移1位 ；*/class Solution &#123;public: int singleNumber(vector&lt;int&gt;&amp; nums) &#123; int res = 0; for(int k= 0; k &lt; 32; k++)&#123; int mask = 1 &lt;&lt; k ; int cout = 0; for(auto num : nums)&#123; if(num &amp; mask) cout++; &#125; if(cout % 3 != 0) res |= mask; &#125; return res; &#125;&#125;; 子串变位词(有效的字母异位词)1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071/**给定两个串a和b，问b是否是a的子串的变位词例：a = hello , b = lel,lle,ello 都是 true b = elo 是false思路:滑动窗口 + 维护数组array[26] = 0for(int index : b.size() -1) array[b[index] - 'a'] ++; onZero++; a['l'] a['e' = 4] onZero = 3; 2 1for(int index : a.size() -1)&#123; array[a[index] - 'a'] -- == 0; onZero --; //if(onZero == 0) -&gt; true; a['h'] a['e'] a['l'] -1 0 1 array[a[index] - 'a'] -- == -1; onZero ++; index 会滑动&#125;return false;*//* 普通版*/class Solution&#123; public: bool isAnagram(String s, String t)&#123; if(s.length() != t.length) return false; int a[26] = &#123;0&#125;; int length = sizeof(a)/sizeof(a[0]); for(int i =0; s[i] != '\0'; i++)&#123; a[s[i] - 'a']++; a[t[i] - 'a']--; &#125; for(int i = 0 ; i &lt; length ; i++) if(a[i] != 0) return false; return true; &#125; &#125;// 升级 窗口滑动int nonZero = 0;for(int i =0; i &lt; lenb; ++i) if(++num[b[i] - 'a'] == 1) ++nonZero;//非0出现//找子串for(int i = 0; i &lt; lenb; ++i)&#123; int c= a[i] - 'a'; --num[c]; if(num[c] == 0) --nonZero; else if(num[c] == -1) ++nonZero;&#125;if(nonZero == 0 ) return true;//滑动窗口 向右移动// new a[i-lenb +1 , i]// old a[i-lenb , i-1]// 扔 a[i-lenb] 加入a[i]for(int i = lenb; i &lt; lena; i++)&#123; int c = a[i - lenb] - 'a'; ++num[c]; if(num[c] == 1) ++nonZero; else if(num[c] == 0) --nonZero; c = a[i] -'a'; --num[c]; if(num[c] == 0) --nonZero; else if(num[c] == -1) ++nonZero; if(nonZero == 0) return true;&#125;]]></content>
      <categories>
        <category>c++</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ks8概念总结]]></title>
    <url>%2F2019%2F08%2F13%2FKS8%E6%A6%82%E5%BF%B5%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[KS8概念总结模型图技术迭代部署大规模集群 模型 架构 实现高可用架构三大指标 高可用、高性能、高并发 Zookeeper 负载均衡：实现轮询机制。防止阻塞 集群：必须实现数据同步，Redis 高可用：一直可用，实现崩溃恢复 A（down &amp; resume) B(up) C ks8高可用集群搭建节点配置 步骤： 关闭交换空间 避免开机启动交换空间 关闭防火墙 配置 DNS 安装 Docke 配置 Docker 加速器 安装 kubeadm，kubelet，kubectl 同步时间:时间要统一 配置 IPVS 配置内核参数\ 修改 cloud.cfg 是修改hostname 单独节点 配置 IP 配置主机名 安装 HAProxy （高可用）+ Keepalived（负载均衡） Keepalived概述ks8 Master阶段运行组件 kube-apiserver:提供资源操作的唯一入口（提供认证、授权、访问控制、api注册和发现) kube-scheduler：负责资源调度 ，将pod调度到相应机器上。 kube-controller-manager：负责维护集群状态（故障检测、自动扩展。。。） Keepalived当master挂了，将其他slaver接上去 实现图解 部署 Kubernetes 集群 初始化 Master 加入 Master 节点 加入 Node 节点 验证集群状态 验证高可用注意 重启之后ipvs要重新执行一哈 问题解决Node无法加入集群替换 Calico（网络插件） 网段为我们虚拟机不重叠的网段（这里用的是 Flannel 默认网段） 如果Calico网段与master、slaver网段重叠就会导致Node无法加入集群。 ks8重置 删除kubectl配置 启动ipvs 导出并修改配置文件 改calico网段 kubeadm初始化 配置kubectl 下载Calico 配置文件并修改 611 行 /name: CALICO_IPV$POOL_CIDR 的value 直接应用本地Calico 加入Master结点（最后 配置mkdir babbalala~~ dubectl get node) 通过资源配置运行容器(部署容器)测试启动顺序 Pod Deployment 内部访问 Service 外部访问机制 12345678910111213141516171819202122232425262728293031kubectl get node #结点状态master01: vi /kubernetes/yml/nginx-deployment.yml #设置deploymentkubectl create -f nginx-deployment.ymlkubectl get pod #查看podkubectl get deployment #看看deployment 开两个实例master01: vi /kubernetes/yml/ nginx-service.yml #设置servicekubectl get service #查看service端口： 80：30066 （30066指的是node 的pod暴露30066端口，再由pod映射到nginx 的80端口）kubectl describe service nginx-http #下面NodePort: 30066/TCP#使用LoadBalancer master slaver 端口都暴露master01：30066master02：30066slaver01：30066slaver02: 30066kubectl delete -f nginx-service.yml #停掉#想要把30066改成80端口vi /kubernetes/yml/ nginx-service.ymlprots: -prot: 80 #Service 端口 targetPort: 80 #Pod 端口 将Service暴露端口转发到Pod端口上 nodePort: 80 # 本来是30066 但是报错 他的范围30000-32767kubectl create -f nginx-service.yml #重开#解决办法vi /etc/kubernetes/manitestls/kube-apiserver.yml#增加配置--service-node-prot-range=2-65545#ks8重启 或者 他自动重启#验证kubectl create -f nginx-service.ymlkubectl describe service nginx-http Ingress统一访问入口ClusterIP服务内部访问方式：外部proxy模式访问内部 123kubectl get service type ClusterIP 三种外部访问方式NodePort在所有节点（虚拟机）上开放一个特定端口 每个端口一种服务 默认模式（官方不推荐） 调试的时候用 LoadBalancer在NodePort加了负载均衡 Ingress扮演智能路由 或 集 群入口 （类似API网关） 例如：部署Tomcat只允许在内网访问，需要Ingress提供反向代理功能路由到Tomcat上 部署Tomcat tomcat.yml（Devlopment+Service） ClusterIP设置 watch kubectl get pods # 查看运行状态 kubectl get deployment kubectl get service kubectl describe service tomcat-http 没有nodeport 限制外网访问 下载Nginx Ingress Controller 配置文件 &amp; 修改 hostNetwork: true kubectl get pods -all -namespaces 多了 ingress-nginx 部署ingress -&gt; ingress.yml kubectl get pods -n ingress-nginx -o wide ip: 192.168.141.161 SwitchHosts : 192.168.141.161 域名 数据持久化NFS+PV/PVC NFSRPC通信，分布式文件系统 部署 安装NFS服务端 安装NFS客户端 验证NFS服务 PV和PVC持久卷提供者 持久卷消费者 NFS网络方案 pv：规格集群资源 pvc：分配集群资源 create pv.yml pvc.yml 部署mysql 8 连接pv pvc 出现问题：没有个性化配置 ConfigMap用来存储配置文件的ks8资源对象，放在etcd内，一种外挂配置。解耦 即：可是用ConfigMap配置MYSQL Dashboard运行界面 CI/CD环境： java git mvn]]></content>
      <tags>
        <tag>分布式</tag>
        <tag>kubernetes</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[时间算法对应使用算法]]></title>
    <url>%2F2019%2F08%2F11%2F%E6%97%B6%E9%97%B4%E7%AE%97%E6%B3%95%E5%AF%B9%E5%BA%94%E4%BD%BF%E7%94%A8%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[时间算法对应使用算法1s 2s c++:指令执行次数：10^8 n &lt;=30, 指数级别； dfs+ 剪枝 n &lt;= 100 n^3 floyd]]></content>
      <categories>
        <category>c++</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RabbitMQ]]></title>
    <url>%2F2019%2F08%2F11%2FRabbitMQ%2F</url>
    <content type="text"><![CDATA[RabbitMQ控制台 用户 数据库 授权 Overview Ports and contexts amqp协议 clustering http Connections Channels Exchanges Queues Admin 简单队列示例RabbitMQ消息队列1234567891011121314151617181920212223 //获取MQ连接的工具类public class ConnectionUtiles&#123; public static Connection getConnection()&#123; //连接工厂 ConnectionFactory factory = new ConnectionFactory(); //设置服务地址 factory.setHost("127.0.0.1"); //端口AHQP 5672 factory.setPort(5672); //vhost facotry.setVirtualHost("/newMySql"); //用户名 factory.setUsername("miki"); //密码 facotry.setPassword("miki666"); //获取连接 return factory.newConnection(); &#125; 生产者1234567891011121314151617181920public class Send&#123; private static final String QUEUE_NAME = "test_simple_queue"; public static void main(String[] args)&#123; //拿到连接 Connection connection = ConnectionUtils.getConnection(); //创建通道 Channel channle = connection.createChannel(); //队列 声明 channel.queueDeclare(QUEUE_NAME,false,false,false,null); //发送 String msg = "hello simpel"; channel.basePublish("",QUEUE_NAME，null,msg.getBytes()); //关闭 channel.close(); conneciton.close(); &#125;&#125; 消费者12345678910111213141516171819202122232425262728293031323334353637383940public class Recv&#123; private static final String QUEUE_NAME = "test_simple_queue"; public static void main(String[] args)&#123; //拿到连接 Connection connection = ConnectionUtils.getConnection(); //创建通道 Channel channle = connection.createChannel(); //队列 声明 channel.queueDeclare(QUEUE_NAME,false,false,false,null); //=============老版本==================================================== //定义队列的消费者 QueueingConsumer consumer = new QueueingConsumer(channel); //监听 channel.basicConsumer(QUEUE_NAME,true,consumer); while(true)&#123; Doliver dalivery = consumer.nextDelivery(); String msgString = new String(dalivery.getBody()); sout(msgString); &#125; //===================老版本============================================= //===================新版本============================================= //观察者模式 队列有数据 消费者DefaultConsumer lamdba -&gt; channel 回调 handleDelivery //这里重写方法 new DefaultConsumer(channel)&#123; @Override public void handleDelivery(String consumerTag,Envelope envelope,BasicProperties properties,byte[] body) throws IOException&#123; String msg = new String(body,"utf-8"); scout(msg); &#125; &#125;; //消费者监听队列 阻塞 -》 android Button 监听事件 addListener channel.basicConsumer(QUEUE_NAME,true,consumer); //===================新版本============================================= &#125;&#125; 旧：监听消费者，while循环当有消息时return 新：channel被消费者监听时，回调 handleDelivery。 简单队列不足 耦合性高，生产者一一对应消费者，当出现多个消费者消费队列则不行；队列名变更，同时变更（生产者，消费者）。 消费者与业务结合，消费者接受消息进行处理，需要时间，就会在队列积压很多消息。 解决方案 工作队列：一个生产者对应多个消费者。 工作队列生产者12345678910111213141516171819202122public class Send&#123; private static final String QUEUE_NAME = "test_work_queue"; public static void main(String[] args) throws IOException,TimeoutException&#123; /* |--c1 * p --Queue--| * |--c2 */ //拿到连接 Connection connection = ConnectionUtils.getConnection(); //创建通道 Channel channle = connection.createChannel(); //队列 声明 channel.queueDeclare(QUEUE_NAME,false,false,false,null); for(int i = 0 ; i &lt; 50 ; i++ )&#123; String msg = "hello" + i; channel.basicPublish("",QUEUE_NAME,null,msg.getBytes()); Thread.sleep(i*10); // 抛出异常 &#125; channel.close(); connection.close(); &#125;&#125; 消费者more1234567891011121314151617181920212223242526272829303132public class Recv&#123; private static final String QUEUE_NAME = "test_work_queue"; public static void main(String[] args)&#123; //拿到连接 Connection connection = ConnectionUtils.getConnection(); //创建通道 Channel channle = connection.createChannel(); //队列 声明 channel.queueDeclare(QUEUE_NAME,false,false,false,null); //定义消费者 Consumer consumer = new DefaultConsumer(channel)&#123; @Override public void handleDelivery(String consumerTag,Envelope envelope,BasicProperties properties,byte[] body) throws IOException&#123; String msg = new String(body,"utf-8"); scout(msg); try&#123; Thread.sleep(2000); &#125;catch(InterruptedExceptin e)&#123; e.printStackTrace(); &#125;finally&#123; scout("done"); &#125; &#125; &#125;; boolean.autoAck =true; channel.basicConsumer(QUEUE_NAME,autoAck,consumer); &#125;&#125;//消费者2同理 简单队列不足 消费者1 &amp; 2 处理的消息都是一样：轮询分发（round-robin),无论谁忙谁闲，都不会都给，都是你一个我一个均摊分发。 解决方案使用basicQos（perfetch =1 ），消费者手动反馈（我已经做完了),即关闭自动应答ack改为手动。 公平分发Fair dispatch消费者加入回执操作123456789101112131415161718//需要发送确认消息public class Recv&#123; //~~~~~~~~获取连接~~~~~~~ //~~~~~~~获取channel~~~~~~~~ //~~~~~~~~声明队列~~~~~~~ //每个消费者发送确认消息之前，消息队列不发送下一个消息到消费者，一次只处理一次数据 channel.basicQos(1); //Channel channel = new DefaultConsumer(channel) ~~~finally&#123; scout("done"); //手动回执 channel.basicAck(envelope.getDeliveryTag(),fasle);&#125;&#125;; boolean autoAck = true; channel.basciConsumer(QUEUE_NAME,autoAck,consumer);&#125; 消息应答与持久化boolean autoAck = true; (自动确认模式)，一旦rebbit消息分发给消费者，消息就会从内存中删除。 坏处：如果消费者突然失败，就会丢失正在处理的消息。 boolean autoAck = false(默认，手动确认模式)，如果消费者突然失败，就会将消息交付给其他消费者。 Message acknowlegment ​ rabbitmq挂了，消息也会丢失 。解决方案-&gt;持久化 boolean durable = false channel.queueDeclare(QUEUE_NAME,durable) // 报错原因：把durable把false改true不可，是因为已经定义了QUEUE_NAME=test_work_queue，这个队列是未持久化，不可重新定义已存在的队列。重建一个队列（改名字）就可定义持久化。 工作队列缺点生产者发送的消息不能被消费者共享。 订阅模式交互机模型1234/* --&gt;|--queue --&gt;c1 * p --X--| * --&gt;|--queue --&gt;c2 */ 一个生产者多个消费者 每个消费者有自己的队列 生产者把消息发到交换机 队列要绑定到交换机 生产者发送 -&gt;消息 -&gt; 交换机 –&gt; 队列：实现一个消息被多个消费者消费。 例如：商品名字改了，搜索引擎改，前台变。 生产者123456789101112131415161718public class Recv&#123; private static final String EXCHANGE_NAME = "test_exchange_fanout"; public static void main(String[] args)&#123; //拿到连接 Connection connection = ConnectionUtils.getConnection(); //创建通道 Channel channle = connection.createChannel(); //队列 声明 交换机 channel.exchangeDeclare(EXCHANGE_NAME,"fanout"); //发送消息 String msg = "hello"; channel.basicPublish(EXCHANGE_NAME,"",null,msg.getBytes()); scout("Send" +msg); //close channel.close(); connection.close();&#125; 消费者one1234567891011121314151617181920212223242526272829303132public class Recv&#123; private static final String QUEUE_NAME = "test_exchange_fanout_email"; private static final String EXCHANGE_NAME = "test_exchange_fanout"; public static void main(String[] args)&#123; //拿到连接 Connection connection = ConnectionUtils.getConnection(); //创建通道 Channel channle = connection.createChannel(); //队列 声明 channel.queueDeclare(QUEUE_NAME,false,false,false,null); //绑定队列到交换机 channel.queueBind(QUEUE_NAME,EXCHANGE_NAME,"") //定义消费者 Consumer consumer = new DefaultConsumer(channel)&#123; @Override public void handleDelivery(String consumerTag,Envelope envelope,BasicProperties properties,byte[] body) throws IOException&#123; String msg = new String(body,"utf-8"); scout(msg); try&#123; Thread.sleep(2000); &#125;catch(InterruptedExceptin e)&#123; e.printStackTrace(); &#125;finally&#123; scout("done"); &#125; &#125; &#125;; boolean.autoAck =true; channel.basicConsumer(QUEUE_NAME,autoAck,consumer); &#125;&#125; 消费者two1234567891011121314151617181920212223242526272829303132public class Recv&#123; private static final String QUEUE_NAME = "test_exchange_fanout_sms"; private static final String EXCHANGE_NAME = "test_exchange_fanout"; public static void main(String[] args)&#123; //拿到连接 Connection connection = ConnectionUtils.getConnection(); //创建通道 Channel channle = connection.createChannel(); //队列 声明 channel.queueDeclare(QUEUE_NAME,false,false,false,null); //绑定队列到交换机 channel.queueBind(QUEUE_NAME,EXCHANGE_NAME,"") //定义消费者 Consumer consumer = new DefaultConsumer(channel)&#123; @Override public void handleDelivery(String consumerTag,Envelope envelope,BasicProperties properties,byte[] body) throws IOException&#123; String msg = new String(body,"utf-8"); scout(msg); try&#123; Thread.sleep(2000); &#125;catch(InterruptedExceptin e)&#123; e.printStackTrace(); &#125;finally&#123; scout("done"); &#125; &#125; &#125;; boolean.autoAck =true; channel.basicConsumer(QUEUE_NAME,autoAck,consumer); &#125;&#125; 现象：消费者1 消费者2 共享生产者发送的消息 交换机缺点一方面接收生产者消息，另一方面向队列推送消息。但是不能把消息交给指定queue 无交换机 channel.basicPublish(&quot;&quot;,&quot;&quot;) 改变 -&gt; 有交换机 没有路由 channel.exchangeDeclare(EXCHANGE_NAME,&quot;fanout&quot;) //不处理路由链 channel.basicPublish(EXCHANGE_NAME,&quot;&quot;) 路由模式路由模型12345/* | -error-&gt;|--queue --&gt;c1 * p --X ：key--| * | -info-&gt;| * |-warning-&gt;| --queue --&gt;c2 * | -error-&gt;| 生产者12345678910111213141516171819public class Recv&#123; private static final String EXCHANGE_NAME = "test_exchange_direct"; public static void main(String[] args)&#123; //拿到连接 Connection connection = ConnectionUtils.getConnection(); //创建通道 Channel channle = connection.createChannel(); //队列 声明 交换机 + 路由 direct channel.exchangeDeclare(EXCHANGE_NAME,"direct"); //发送消息 String msg = "hello"; String routingKey = "error"; channel.basicPublish(EXCHANGE_NAME,routingKey,null,msg.getBytes()); scout("Send" +msg); //close channel.close(); connection.close();&#125; 消费者123456789101112131415161718192021222324252627282930313233343536public class Recv&#123; private static final String QUEUE_NAME = "test_exchange_direct"; private static final String QUEUE_NAME = "test_queue_direct_i"; public static void main(String[] args)&#123; //拿到连接 Connection connection = ConnectionUtils.getConnection(); //创建通道 Channel channle = connection.createChannel(); //队列 声明 channel.queueDeclare(QUEUE_NAME,false,false,false,null); //绑定队列到交换机 channel.queueBind(QUEUE_NAME,EXCHANGE_NAME,"error"); //绑定多个 channel.queueBind(QUEUE_NAME,EXCHANGE_NAME,"info"); channel.queueBind(QUEUE_NAME,EXCHANGE_NAME,"warning"); //定义消费者 Consumer consumer = new DefaultConsumer(channel)&#123; @Override public void handleDelivery(String consumerTag,Envelope envelope,BasicProperties properties,byte[] body) throws IOException&#123; String msg = new String(body,"utf-8"); scout(msg); try&#123; Thread.sleep(2000); &#125;catch(InterruptedExceptin e)&#123; e.printStackTrace(); &#125;finally&#123; scout("done"); &#125; &#125; &#125;; boolean.autoAck =true; channel.basicConsumer(QUEUE_NAME,autoAck,consumer); &#125;&#125; 路由模式缺点生产者路由key只能一个。不能多个匹配，即不能多对多。 主题模式主题模型 模式匹配 #匹配一个或多个 *匹配一个 生产者：商品-&gt;发布（goods.add) 删除 修改 查询 消费者1：(goods.add) 消费者2：(goods.#) 生产者12345678910111213141516171819public class Recv&#123; private static final String EXCHANGE_NAME = "test_exchange_topic"; public static void main(String[] args)&#123; //拿到连接 Connection connection = ConnectionUtils.getConnection(); //创建通道 Channel channle = connection.createChannel(); //队列 声明 交换机 + 路由 direct channel.exchangeDeclare(EXCHANGE_NAME,"topic"); //发送消息 String msg = "商品 .."; String routingKey = "goods.add"; channel.basicPublish(EXCHANGE_NAME,routingKey,null,msg.getBytes()); scout("Send" +msg); //close channel.close(); connection.close();&#125; 消费者12345678910111213141516171819202122232425262728293031323334353637public class Recv&#123; private static final String QUEUE_NAME = "test_exchange_direct"; private static final String QUEUE_NAME = "test_queue_direct_i"; public static void main(String[] args)&#123; //拿到连接 Connection connection = ConnectionUtils.getConnection(); //创建通道 Channel channle = connection.createChannel(); //队列 声明 channel.queueDeclare(QUEUE_NAME,false,false,false,null); //绑定队列到交换机 channel.queueBind(QUEUE_NAME,EXCHANGE_NAME,"goods.add"); //消费者2--------------------------------------- channel.queueBind(QUEUE_NAME,EXCHANGE_NAME,"goods.#"); //消费者2--------------------------------------- channel.basicQos(1); //定义消费者 Consumer consumer = new DefaultConsumer(channel)&#123; @Override public void handleDelivery(String consumerTag,Envelope envelope,BasicProperties properties,byte[] body) throws IOException&#123; String msg = new String(body,"utf-8"); scout(msg); try&#123; Thread.sleep(2000); &#125;catch(InterruptedExceptin e)&#123; e.printStackTrace(); &#125;finally&#123; scout("done"); &#125; &#125; &#125;; boolean.autoAck =true; channel.basicConsumer(QUEUE_NAME,autoAck,consumer); &#125;&#125; 在路由的基础上，消费者多了匹配符，简化消费者用多个通道来对应queue。 即，主题模式更加符合模块化接收，（从一个管子变成口子） 消息确认机制（事务+confirm)通过持久化数据，解决消费者异常导致数据丢失问题。但是不知道消息发出去是否接收到。 两种解决方案 AMQP实现事务机制（类似mysql） Confirm模式 AMQP实现事务机制 txSelect:用于用户将当前channel设置成transation模式 txCommit：用于提交事务 txRoolback：回滚事务 生产者123456789101112131415161718192021222324252627 private static final String QUEUE_NAME = "test_queue_tx"; public static void main(String[] args)&#123; //拿到连接 Connection connection = ConnectionUtils.getConnection(); //创建通道 Channel channle = connection.createChannel(); //队列 声明 交换机 + 路由 direct channel.queueDeclare(QUEUE_NAME,false,false,false,null); //发送消息 String msg = "hello tx .."; try&#123; channel.txSelect(); channel.basicPublish("",QUEUE_NAME,null,msg.getBytes()); //------异常------ // int x = 1/0; //------异常------ channel.txCommit(); scout("Send" +msg); &#125;catch(Exception e)&#123; channel.txRollback(); scout("tx rollback"); &#125; //close channel.close(); connection.close();&#125; 消费者12345678910111213141516171819202122public class Recv&#123; private static final String QUEUE_NAME = "test_queue_tx"; public static void main(String[] args)&#123; //拿到连接 Connection connection = ConnectionUtils.getConnection(); //创建通道 Channel channle = connection.createChannel(); //队列 声明 channel.queueDeclare(QUEUE_NAME,false,false,false,null); //定义消费者 Consumer consumer = boolean.autoAck =true; channel.basicConsume(QUEUE_NAME,true,new DefaultConsumer(channel)&#123; @Override public void handleDelivery(String consumerTag,Envelope envelope,BasicProperties properties,byte[] body) throws IOException&#123; scout(new String(body,"utf-8")); &#125; &#125;); &#125;&#125; 缺点：事务的大量提交，会降低生产者的吞吐量。 Confirm模式实现原理]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>RabbitMQ</tag>
        <tag>消息队列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[oAth2(二)]]></title>
    <url>%2F2019%2F08%2F09%2FoAuth2%E6%A1%88%E4%BE%8B%2F</url>
    <content type="text"><![CDATA[oAuth2案例内存、jdbc存储令牌 AuthorizationServerConfiguration:认证client、secret 和授权码通过 提供资源 http://client:secret@localhost:8080/oauth/token= 授权码 WebSecurityConfiguartion：认证功能 提供授权码 文字流程：用户 -》web（账户） 获得授权码； 用户post：client_id:secret+授权码 获得 scope区域内的资源。 角色的权限访问控制 RBAC 角色 ACL 控制列表 ABAC 属性 PBAC 策略 来源：论文、社区、RFC6749 RBAC：最小权限、责任分离、数据抽象who（认证服务器）、what（权限针对的对象 &amp; 资源 授权服务器）、how(具体的权限) who:user what: 静态资源 功能操作，数据列 动态资源 数据、文章、相册、笔记 post 查看 新增 photos how： CRUD user role角色 permission权限 user_role role_permission 关系图： 模块图：]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>oAth2</tag>
        <tag>sso</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Gradle]]></title>
    <url>%2F2019%2F08%2F09%2FGradle%E6%A1%88%E4%BE%8B%2F</url>
    <content type="text"><![CDATA[Gradle案例Project &amp;&amp; taskGroovy基本语法构建任务&amp;运行123456789101112task hello&#123; doLast &#123; println 'Hello world' &#125;&#125;//改良task hello &lt;&lt; &#123; println 'Hello world'&#125;//命令行&gt; gradle -q helloHello world gradle 构建脚本+ 运行脚本 运行任务前要依赖的任务12345678910task "task$counter" &lt;&lt; &#123; println " I'm task number $counter"&#125;//加入依赖task0.dependsOn task2, task3&gt; gradle -q task0I'm task number 0I'm task number 2I'm task number 3 喝水需要有杯子和烧好的水 声明任务之间的运行顺序1234567891011121314151617181920212223242526task after(dependsOn: 'before') &lt;&lt; &#123; println 'after'&#125;task before &lt;&lt; &#123; println 'before'&#125;&gt; gradle -q after beforeaftertask hello &lt;&lt; &#123; println 'hello'&#125;hello.doFirst &#123; println 'ask:'&#125;hello.doLast &#123; println 'shank hands'&#125;hello &lt;&lt; &#123; println 'leave'&#125;// &lt;&lt; 是 doLast 简写// $hello.name 会出来 hello //获取当前任务的名字&gt;gradle -q hello 喝水前要拿杯子，喝完要洗杯子 任务参数化12345678task myTask&#123; ext.myProperty = "myValue"&#125;task printTaskProperty &lt;&lt; &#123; println myTask.myProperty&#125;&gt; gradle -q pritnTaskPropertymyValue 杯子的名字 Ant构建工具12345678910111213141516171819task loadfile &lt;&lt; &#123; def files = file('../antLoadfileResources').listFiles().sort() files.each &#123; File file -&gt; if (file.isFile())&#123; ant.loadfile(srcFile: file, property: file.name) println " *** $file.name ***" println "$&#123;ant.properties[file.name]&#125;" &#125; &#125; &#125;//遍历 ../antLoadfileResources 所有文件 打印出来&gt; gradle -q loadfile*** agile.manifesto.txt ***Individuals and interactions over processes and toolsWorking software over comprehensive documentationCustomer collaboration over contract negotiationResponding to change over following a plan*** gradle.manifesto.txt *** 脚本-&gt;任务管理+自动化 Java构建入门项目编译class、打包jar、运行javac gradle bulid: 编译测试代码，并生成含所有类和资源的jar文件。 clean：删除build的所有东西 assemble： 编译 &amp; 打包代码-&gt; 可执行文件 check：编译 &amp; 测试 外部依赖 提取 &amp; 放入 依赖 12345678910111213//加入依赖// commons-coolections 加入编译阶段// junit 加入到了测试编译阶段.dependencies&#123; compile group: 'commons-coolections', name: 'commons-collections', version: '3.2' testCompile group: 'junit', name: 'junit', version: '4.+' &#125;//远程仓库repositories&#123; maven&#123; url 'http://alibaba~~~~~/re~~/' &#125;&#125; 定制项目 项目名+版本号 定制 MANIFEST.MF 文件 1234567sourceCompatibility = 1.5version = '1.0'jar &#123; manifest &#123; attributes 'Implementation-Title': 'myfirstProject', 'Implementation-Version': version &#125;&#125; 发布JAR文件 本地仓库repos中 gradle uploadArchives命令发布jar文件 1234567uploadArchives&#123; repositories&#123; flatDir&#123; dirs 'repos' &#125; &#125;&#125; 合并123456789101112131415161718192021222324252627282930313233343536373839404142//------------------------------加入插件apply plugin: 'java'apply plugin: 'eclipse'//------------------------------//------------------------------ 自定项目名+版本号sourceCompatibility = 1.5version = '1.0'jar &#123; manifest &#123; attributes 'Implementation-Title': 'Gradle Quickstart', 'Implementation-Version': version &#125;&#125;//------------------------------//------------------------------ 远程仓库地址repositories &#123; mavenCentral()&#125;//------------------------------//------------------------------ 项目依赖dependencies &#123; compile group: 'commons-collections', name: 'commons-collections', version: '3.2' testCompile group: 'junit', name: 'junit', version: '4.+'&#125;//------------------------------//------------------------------测试时添加key valuetest &#123; systemProperties 'property': 'value'&#125;//------------------------------//------------------------------ 打包上传仓库uploadArchives &#123; repositories &#123; flatDir &#123; dirs 'repos' &#125; &#125;&#125; 多项目构建]]></content>
      <categories>
        <category>部署</category>
      </categories>
      <tags>
        <tag>gradle</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[sso单点登录]]></title>
    <url>%2F2019%2F08%2F09%2Fsso%E5%8D%95%E7%82%B9%E7%99%BB%E5%BD%95%2F</url>
    <content type="text"><![CDATA[Nginx nginx 服务器： 192.168.75.128：81 tomact1： 192.168.75.128：9090 tomcat2：192.168.75.128：9091 nginx IP:192.168.75.128:81 配置： listen: 80 ​ tomcat_pool: http://192.168.75.128:9090 ​ : http://192.168.75.128:9091 作用： 虚拟主机CDN /反向代理 SSO单点登录redis c语言 key-value 字符： json 散列：Map 列表：list 集合：Set 有序集合：HashSet 应用场景 缓存 分布式集群架构的session分离 （http无状态 cookie 有状态 session服务端 判断用户是谁) 好友列表 消息队列 不用 我们用专门的 排行榜 网站访问量 数据 数字自增 日期 毫秒 并发 yyymmddhhmmss+redis的自增数字 订单号的生成方案 Redis高可用解决方案 keepalived zookeeper sentinel 主要解决单点故障 应用 -&gt; sso单点登录 传统登录机制 session会话机制 通过 将token 存到客户端的cookie ，之后每次客户端请求时携带token值让客户端识别WhoAmI 缺陷 同源机制：必须在同源下才可以共享token 当创建多个不同服务器时（php/java/.net/) 所提供的session机制不同，会导致不识别 cookie不安全 SSO单点登录 解决上诉痛点 步骤： 查询用户信息 redis到mysql service层 获取cookie中的token的value，作为key查询Redis是否有value(用户名)：有(已经登陆过) 提供user。 无 继续 去数据库查询有无该用户信息 ,有，将username，password存到redis（第一次登陆)，无,返回null(未登录) sso登录服务 controller层 返回非null（且第一次登陆) 登录成功 用CookieUtil生成一个随机num，&lt;num,userId&gt;存放到Redis中（熔断了返回刷新重试)， &lt;token,num&gt;存放到客户端， -&gt; 登录成功 返回null -&gt; 登录失败/未登录 效果：通过redis实现统一的session管理，解决缺陷2，无论何种服务器，存储数据格式方案一致，token从客户端到服务端两次分离，解决cookie不安全（缺陷3)；同源机制可以通过nginx反向代理解决/Zuul网关。 th拦截器可以用vue判断json返回 是否执行跳转。 拦截器还有个拦截Config 拦截所有资源，去到下列拦截执行器中 123456789101112131415161718192021222324252627282930313233package com.admin.interceptor;public class WebAdminInterceptor implements HandlerInterceptor&#123; @Overrider public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler)&#123; //cookie 为空 一定没有登陆 -&gt;去单点登录 String token = CookieU ~~ response.senRedirect("http://login.html"); // 该常量可以放进config里面 return false; &#125; @Overrider public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handle, ModelAndView modeAndView)&#123; //cookie有，但是不一定登录 session里那数据 HttpSession session = request.getSession(); User user = session.getAttribute("user"); //局部会话 //user不为空 处于局部会话的已登录状态---------------------------- modelAndView.addObject("user",user); //提供给下一个跳转的有缘人 //user为空 处于未登录状态-------------------------------------- //Cookie 拿到的token ，value作为key去Redis查询 ，拿到loginCode 去mapper拿到完整user //如果loginCode不为空 -&gt; 已登录 创建局部会话，并把user存放到里面 request.getSession().setAttribute("user",user); //二次确认 user == null ; //直接重定向到登录系统 &#125; @Overrider public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handle, Execption ex)&#123; &#125;&#125; 1234567891011121314//出现问题//RedisService无法被自动注入 class InterceptorConfig implements WebMvcConfigurer&#123; @Bean WebAdminInterceptor webAdminInterceptor()&#123; return new WebAdminInterceptor(); &#125; @Override public void addIntercepotrs(InterceptorRegistry registry)&#123; registry.addIntercptor(new WebAdminInterceptor()) .addPathPatterns("/**") .excluedPathPatterns("/static"); &#125; &#125; 跨域：同源策略下的脚本安全问题，浏览器限制脚本只能在同源下执行，但是现在是微服务，可能位于不同ip/域名/端口，导致存在。 解决： CORS跨资源共享，浏览器自动完成，在header设置即可，关键在服务器实现CORS接口即可:-1:不支持老式浏览器 Jsonp 利用&lt;script&gt;的开放策略 ，前端从json解析器变成JavaScript直译器，需要目标服务器配合calback函数。:+1:支持老式浏览器，:-1:只支持get请求,需要客户端服务端同时改变 Nginx反向代理：挺好的 方案3步骤：在docker-compose.yml 12345678910111213user nginx:~~~~~server&#123; listen 80; server_name 192.168.75.128; location /&#123; add_header Access-Control-Allow-Origin *; add_header Access-Control-Headers X-Requested-With; add_header Access-Control-Methods GET,POST,OPTIONS; 数据卷 &#125;&#125;]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>oAth2</tag>
        <tag>sso</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[oAth2(一)]]></title>
    <url>%2F2019%2F08%2F08%2FoAuth2%E5%89%8D%E8%A8%80%2F</url>
    <content type="text"><![CDATA[oAth2背景传统登录状态出现问题 多个服务分别部署，需要分别登录 第三方应用介入对用户登录信息的需求 用户无法限制第三方应用在某个微服务中的授权范围和使用期限 用户修改登录信息对第三方的应用影响 第三方应用的破解会导致用户密码泄露 OAth2架构模式 交互过程 开放平台交互模型 资源拥有者：用户 客户端：APP 服务提供方： 认证服务器 资源服务器 步骤： 用户 - 输入账号密码 -&gt; 腾讯提供的开放平台（提供：给谁授权、授权范围) 腾讯提供的开放平台登录成功 - 有道云笔记 授权码-&gt; 有道云笔记根据授权码访问腾讯 认证服务器去拿 访问令牌，用 访问令牌 去腾讯的 资源服务器， 资源服务器 根据令牌上的（授权人 &amp; 授权范围 ) 提供相应的资源：（用户昵称、头像、性别）。 有道云笔记根据获取的信息先注册个账号（填入相关信息 ： 不过你还要再完善相关信息：手机这些） 总结：开放平台只是获取部分信息，简化一定的注册流程 遵循OAuth2.0协议 即接口提供认证和授权标准 例如：接口JAP @Table @Column @Id Hibernate实现 用Spring Security 实现 令牌的访问与刷新原始令牌风险url：http://www.sdfsdf/usr/token=123 toekn被人发现，被爬虫一直刷 token一直在，别人抓包，就能抓到令牌，数据被别人拿去。 解决方案： 令牌刷新，用旧令牌获取新令牌：传入refresh_token 、 client_id 认证服务器通过会返回新的Access Token 要求： Refresh Token 保存在客户端服务器 client_secret机制：client_id(客户端) &lt;-&gt; client_secret（服务端）,在申请client_id会一起把client_secret分配给客户端，client_secret ##妥善保管在服务器##,刷新Access Token ，需要验证client_secret。 url变成： url:http://www.sdfsdf//refresh?refresh_token=&amp;client_id=&amp;client_secret= 所以第三方应用提供： appId = client_id appSecret = client_secret 客户端授权模式 简化模式 纯静态页面应用，APP，小程序，HTML5，第三方天气，个人博客，只有前端js控制权。 授权码模式 密码模式 客户端模式 总结： +访问令牌+ access Toekn + Refresh Toekn]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>oAth2</tag>
        <tag>sso</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java网络编程]]></title>
    <url>%2F2019%2F07%2F28%2FNetty%2F</url>
    <content type="text"><![CDATA[java网络编程1、NIO123456789101112131415161718psvm&#123; ServerSocket ss = new ServerSocket(); ss.bind(new InetSocketAddress("127.0.0.1"),8888); while(true)&#123; Socket s = ss.accept(); new Thread(() -&gt;&#123; heandle(s); &#125;).start(); &#125;&#125;static void handle(Socket s)&#123; try&#123; byte[] bytes = new byte[1024]; int len = s.getInputStream().read(bytes); s.getOutputStream().write(bytes,0,len); &#125;catch &#123;bala&#125;&#125; graph RL ss --bind --> s subgraph server s(s:127.0.0.1:8888) end subgraph listen s --accept--> thread1 s --accept--> thread2 s --accept-->thread3 end NIO会出现的问题 ss.accept()内的线程会 read write 解决方案：轮询 NIO-single Thread（NewNon-Blocking)说明：大管家selector轮询：如果有客户端连接，就处理（单线程）压力很大 1234567891011121314151617181920psvm&#123; ServerSocketChannel ssc = .open(); ssc.socket().bind (~~~); ssc.configureBlocking(false); Selector selector = Selector.open(); ssc.register(selector ,~); while(true)&#123; selector.select(); //轮询选择到的请求 -&gt; 也是阻塞 Set&lt;SelectionKey&gt; key -&gt; selector.selectedKeys(); //事件发生 把当前事件设个key //遍历SelectinKey 把得到的key remove handle(key) &#125;&#125;void handle()&#123; ServerSocketChannel ssc = key.channel(); SocketChannel sc = ssc.accept(); //阻塞 -&gt; false sc.register( //设一个key) &#125; graph RL boy(大管家) --注册--> accept1 boy(大管家) --注册--> accept2 subgraph list key_one key_two end subgraph 插座 accept1 --register--- key_one accept2 --register--- key_two 等待 end ####]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>Netty</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[标签测试]]></title>
    <url>%2F2019%2F07%2F28%2F%E6%A0%87%E7%AD%BE%E6%B5%8B%E8%AF%95%2F</url>
    <content type="text"><![CDATA[随便写写]]></content>
      <tags>
        <tag>Testing</tag>
        <tag>Another Tag</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo第二次试验]]></title>
    <url>%2F2019%2F07%2F28%2Fhexo%E7%AC%AC%E4%BA%8C%E6%AC%A1%E8%AF%95%E9%AA%8C%2F</url>
    <content type="text"><![CDATA[sdfsdfsd]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>博客</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[打 打一个大菠萝呀]]></title>
    <url>%2F2019%2F07%2F27%2F%E6%89%93-%E6%89%93%E4%B8%80%E4%B8%AA%E5%A4%A7%E8%8F%A0%E8%90%9D%E5%91%80%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F07%2F27%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
