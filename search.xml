<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[java基础（二)]]></title>
    <url>%2F2019%2F08%2F31%2Fjava%E5%9F%BA%E7%A1%80%EF%BC%88%E4%BA%8C%EF%BC%89%2F</url>
    <content type="text"><![CDATA[Java基础二其他Equals &amp; hashcode 为什么重写equals还要重写hashcode 不重写的情况下，equal 与= 、hashcode 只是简单的比较对象的内存地址。 重写情况equal下，比较方式发生了变化， equal 比较对象内的成员变量的值是否相等，但是对象a 对象b 成员变量值相等，但是hashcode未重写的情况下还是直接判断内存地址，所以需要并重写hashcode。 Object若不重写hashCode()的话，hashCode()如何计算出来的？ hashCode 相当于key，value 对应 哈希值和散列码 散列码就是哈希函数根据哈希值和对象映射出来的唯一一个值，作为内存地址， 例如 数组 5 f(x) = y%5 数字是 6 则 存在 1的位置上，还有哈希冲突（线程探测、二次探测、伪随机探测、链地址发、 公共溢出区 ） java8新特性 Lambda表达式 &amp;函数式接口 Lambda表达式 函数作为参数 传递给某个方法 123456789101112131415161718Arrays.asList("a","b","c").forEach(e -&gt; sout(e));//复杂语句块Arrays.asList("a","n","c").forEach( e -&gt;&#123; sout(e); sout(e);&#125;);//应用类成员和局部变量final String spearator = ",";Arrays.asList("a","b","c".forEach( (String e) -&gt; sout(e + spearator);));//返回值Arrays.asList("a","b","c").sort((e1,e2) -&gt; e1.compareTo(e2));Arrays.asList("a","b").sort((e1,e2) -&gt;&#123; int result = e1.compareTo(e2); return result;&#125;) Lambda表达式良好兼容 -&gt; 函数接口，（只有一个函数的接口） 该接口可以隐式转换Lambda表达式 默认方法 123456789//函数式接口@FunctionalInterfacepublic interface Functional&#123; void method(); //默认方法 // 高可用 该接口新增方法时 不需要在 已实现该接口的类也添加方法 default void defaultMethod()&#123;...&#125;;&#125; 方法引用 和 landba表达式紧密联系 -&gt; java构造方法紧密 简洁 1 是的发生的 1]]></content>
      <categories>
        <category>c++</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剑指office算法（二）]]></title>
    <url>%2F2019%2F08%2F30%2F%E5%89%91%E6%8C%87office%E7%AE%97%E6%B3%95%EF%BC%88%E4%BA%8C%EF%BC%89%2F</url>
    <content type="text"><![CDATA[剑指office算法（二）机器人的运动范围123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354/**地上有一个 m 行和 n 列的方格，横纵坐标范围分别是 0∼m−1 和 0∼n−1。一个机器人从坐标0,0的格子开始移动，每一次只能向左，右，上，下四个方向移动一格。但是不能进入行坐标和列坐标的数位之和大于 k 的格子。请问该机器人能够达到多少个格子？样例1输入：k=7, m=4, n=5输出：20样例2输入：k=18, m=40, n=40输出：1484解释：当k为18时，机器人能够进入方格（35,37），因为3+5+3+7 = 18。 但是，它不能进入方格（35,38），因为3+5+3+8 = 19。*/class Solution &#123;public: int get_single_sum(int x)&#123; int s = 0; while(x) s += x %10, x /= 10; return s; &#125; int get_sum(pair&lt;int,int&gt; p)&#123; return get_single_sum(p.first) + get_single_sum(p.second); &#125; int movingCount(int threshold, int rows, int cols)&#123; int res = 0; if(!rows || !cols) return 0; vector&lt;vector&lt;bool&gt;&gt; st(rows, vector&lt;bool&gt;(cols)); queue&lt;pair&lt;int,int&gt;&gt; q; q.push(&#123;0,0&#125;); int dx[4]=&#123;-1,0,1,0&#125;, dy[4]=&#123;0,1,0,-1&#125;; while(q.size())&#123; auto t = q.front(); q.pop(); if(get_sum(t) &gt; threshold || st[t.first][t.second]) continue; res++; st[t.first][t.second] = true; for(int i = 0 ; i &lt; 4; i++)&#123; int x = t.first + dx[i], y = t.second + dy[i]; if(x &gt;=0 &amp;&amp; x &lt; rows &amp;&amp; y &gt;=0 &amp;&amp; y &lt; cols) q.push(&#123;x,y&#125;); &#125; &#125; return res; &#125;&#125;; ## 剪绳子123456789101112131415161718192021/**给你一根长度为 n 绳子，请把绳子剪成 m 段（m、n 都是整数，2≤n≤58 并且 m≥2）。每段的绳子的长度记为k[0]、k[1]、……、k[m]。k[0]k[1] … k[m] 可能的最大乘积是多少？例如当绳子的长度是8时，我们把它剪成长度分别为2、3、3的三段，此时得到最大的乘积18。样例输入：8输出：18**/class Solution &#123;public: int maxProductAfterCutting(int length) &#123; int n = length; if( n &lt;= 3) return 1 * (n -1); int res = 1; if(n % 3 == 1) res = 4, n -=4; else if(n % 3 == 2) res = 2, n -=2; while(n) res *= 3, n -=3; return res; &#125;&#125;; 二进制中1的个数12345678910111213141516171819202122232425/**输入一个32位整数，输出该数二进制表示中1的个数。注意：负数在计算机中用其绝对值的补码来表示。样例1输入：9输出：2解释：9的二进制表示是1001，一共有2个1。样例2输入：-2输出：31解释：-2在计算机里会被表示成11111111111111111111111111111110， 一共有31个1。*/class Solution &#123;public: int NumberOf1(int n) &#123; int res = 0; unsigned int un = n; while(un) res += un &amp; 1, un &gt;&gt;= 1; &#125;&#125;; 数值的整数次方123456789101112131415161718192021222324/**实现函数double Power(double base, int exponent)，求base的 exponent次方。不得使用库函数，同时不需要考虑大数问题。注意：不会出现底数和指数同为0的情况样例1输入：10 ，2输出：100样例2输入：10 ，-2 输出：0.01*/class Solution &#123;public: double Power(double base, int exponent) &#123; bool flag = true; if(exponent &lt; 0) flag = false, exponent = -exponent; double res = 1; while(exponent--) res *= base; if(!flag) res = 1 / res; return flag; &#125;&#125;; 在O(1)时间删除链表结点123456789101112131415161718192021222324252627/**给定单向链表的一个节点指针，定义一个函数在O(1)时间删除该结点。假设链表一定存在，并且该节点一定不是尾节点。样例输入：链表 1-&gt;4-&gt;6-&gt;8 删掉节点：第2个节点即6（头节点为第0个节点）输出：新链表 1-&gt;4-&gt;8*//** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: void deleteNode(ListNode* node) &#123; auto p = node -&gt; next; node -&gt; val = p -&gt; val; node -&gt; next = p -&gt; next; delete p; &#125;&#125;; 删除链表中重复的节点1234567891011121314151617181920212223242526272829303132333435/**在一个排序的链表中，存在重复的结点，请删除该链表中重复的结点，重复的结点不保留。样例1输入：1-&gt;2-&gt;3-&gt;3-&gt;4-&gt;4-&gt;5输出：1-&gt;2-&gt;5样例2输入：1-&gt;1-&gt;1-&gt;2-&gt;3输出：2-&gt;3*//** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: ListNode* deleteDuplication(ListNode* head) &#123; auto dummy = new ListNode(-1); dummy -&gt; next = head; auto q = dummy -&gt; next; while(q -&gt; next)&#123; auto p = q -&gt; next; while(p &amp;&amp; q -&gt;next -&gt; val == p -&gt;val) p = p-&gt; next; // 查看要跨几步 p步 if(q-&gt;next &amp;&amp; q -&gt; next -&gt; next == p) q = q -&gt;next; // 跨一步 else q -&gt; next = p; //跨一大步 &#125; return dummy-&gt; next; &#125;&#125;; 机器人达到指定位置方法数1234567891011121314151617181920212223242526272829303132333435363738394041/**假设有排成一行的N个位置，记为1~N，开始时机器人在M位置，机器人可以往左或者往右走，如果机器人在1位置，那么下一步机器人只能走到2位置，如果机器人在N位置，那么下一步机器人只能走到N-1位置。规定机器人只能走k步，最终能来到P位置的方法有多少种。由于方案数可能比较大，所以答案需要对1e9+7取模。输出包括一行四个正整数N（2&lt;=N&lt;=5000）、M(1&lt;=M&lt;=N)、K(1&lt;=K&lt;=5000)、P(1&lt;=P&lt;=N)。输出一个整数，代表最终走到P的方法数对10^9+7取模后的值。输入5 2 3 3输出3说明1).2-&gt;1,1-&gt;2,2-&gt;32).2-&gt;3,3-&gt;2,2-&gt;33).2-&gt;3,3-&gt;4,4-&gt;3*/class Solution &#123;public:int mod = 1e9+7;int walk2(int N, int cur, int rest, int P)&#123; //总长度 当前 剩余步数 终点 vector&lt;vector&lt;int&gt;&gt; dp(cur+1, vector&lt;int&gt;(N+1,0)); dp[0][P] = 0; for(int i = 1; i &lt;= cur; i++)&#123; for(int k = 1; k &lt;= N ; k++)&#123; if(k == 1) dp[i][k] = dp[i-1][2]; else if(k == N) dp[i][k] = dp[i-1][N-1]; else dp[i][j] = dp[i-1][j-1] +dp[i-1][j+1]; &#125; &#125; return dp[cur][N];&#125; int main()&#123; int N, M, K, P; cin &gt;&gt; N &gt;&gt; M &gt;&gt; K &gt;&gt; P; if(N&lt;2 || K&lt;1 || M&gt;N || M&lt;1|| P&gt;N || P&lt;1) return 0; cout &lt;&lt; walk2(N, M, K, P) &lt;&lt; endl; return 0;&#125;&#125; ### 正则表达式匹配123456789101112131415161718192021222324252627282930313233/**请实现一个函数用来匹配包括'.'和'*'的正则表达式。模式中的字符'.'表示任意一个字符，而'*'表示它前面的字符可以出现任意次（含0次）。在本题中，匹配是指字符串的所有字符匹配整个模式。例如，字符串"aaa"与模式"a.a"和"ab*ac*a"匹配，但是与"aa.a"和"ab*a"均不匹配。输入：s="aa"p="a*"输出:true*/class Solution &#123;public: bool isMatch(string s, string p) &#123; int sn = s.size(), pn = p.size(); vector&lt;vector&lt;int&gt;&gt; dp(sn+10, vector&lt;int&gt;(pn+10,0)); dp[0][0] = 1; for(int i = 0; i &lt; sn; i++)&#123; for(int j=1; j &lt; pn; j++)&#123; //如果是 。 if( i &gt; 0 &amp;&amp; p[j-1] == '.')&#123; dp[i][j] = dp[i-1][j-1]; &#125; else if( i &gt; 0 &amp;&amp; p[j-1] == s[i-1] &amp;&amp; p[j-1] != '*')&#123; dp[i][j] = dp[i-1][j-1]; &#125; else if(j &gt; 1 &amp;&amp; p[j-1] == "*") &#123; if() &#125; &#125; &#125; &#125;&#125;;]]></content>
      <categories>
        <category>c++</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java基础]]></title>
    <url>%2F2019%2F08%2F28%2FJava%20%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[Java 基础异常类异常说明如果出错，创建出一个异常类对象，抛出相关信息 继承关系12345678910 Throwable | - Error java内部错误 不会捕获异常 （内部错误） | - Exception | - RuntimeExecption 运行异常 运行阶段 nullpoint | - CheckedException 检查异常 编译阶段 （外部错误） 文件 url IOException等RuntimeExecption ： 空指针 *ptr = null 数组越界 a[10] -&gt; a[111] 算数异常 int 1/0 类型转换异常 shrot s1 = s1 + 1 Throw &amp; Throws 位置不同 throw 是跟着异常对象 用在函数内 throws 跟着异常类 用在函数上 12throw new NumberFormateException();int div(int a, int b ) throws Exception&#123;&#125; 功能性 告知 throws 告知可能会抛出异常 throw 某部分执行到throw一定抛出具体异常对象 且功能结束，告知异常 消极处理 真正处理的是 函数的上级调用者 即：抛出 而不是用try catch 捕获 Finallytry中执行到return语句，不会直接return， 先计算return表达式，把结果保存到临时栈，再执行finally语句，之后才把临时栈的结果返回。 Java容器容器模型 12 ### 装箱&amp;拆箱int 与 integer区别： 数据类型与包装类区别 int：直接存数值 （初始化 = 0） integer：引用指向这个对象（初始值 null） integer a =1; -&gt; integer a = integer.valueOf(1); JavaI/O流字符流String 、StringBuild、 StringBuffer区别 String 定义字符的数据变量 StringBuild StringBuffer 都是拼接字符串， ”a“+”b“ string用到两个字符串变量 ，实际上只用一个把两个拼接，另一个释放就好。 StringBuffer 采用同步机制 但效率慢 。。同理StringBuild Java并发线程内存模型 特点： 每个线程需要从主内存中 获取 变量的值 获取数据之后回放入自己的工作内存中，都是主内存拷贝的副本 线程间无法直接访问对方工作内存 线程工作状态 lock（锁定）：在某一个线程在读取主内存的时候需要把变量锁定。 unlock（解锁）：某一个线程读取玩变量值之后会释放锁定，别的线程就可以进入操作 。 read（读取）：从主内存中读取变量的值并放入工作内存中 。 load（加载）：从read操作得到的值放入工作内存变量副本中 。 use（使用）：把工作内存中的一个变量值传递给执行引擎 。 assign（赋值）：它把一个从执行引擎接收到的值赋值给工作内存的变量 。 store（存储）：把工作内存中的一个变量的值传送到主内存中 。 write（写入）：把store操作从工作内存中一个变量的值传送到主内存的变量中。 线程内部方法 单线程123456789101112131415161718public class one extends Thread&#123; public void run()&#123;........&#125;;&#125;///////////////////2////////////public class two implements Runnable&#123; public void run()&#123;......&#125;;&#125;/////////////3//////////内部////////new Thread(new Runnable()&#123; public void run()&#123; sout("sdfs") ; &#125;&#125;);new Thread(()-&gt;&#123; sout("sdfs") ;&#125;);///////////one a = new one();two b = new two();a.start(), b.start(); #### 多线程使用线程池利用线程池管理线程的创建销毁，【缓存功能】 降低资源消耗 提高响应速度 线程可管理 常用线程池 CacheThreadPool 无界 SynchronizedQueue 无缓存队列 接收任务直接处理 FixedThreadPool 有界 LinkedBlokingQueue 列表阻塞队列 无界队列可缓存 读写分离 SingleThreadPool 单一 LinkedBlokingQueue 指定队列 1 ScheduledThreadPoll 定时周期 CachedThreadPool 无界线程池 1234567891011121314public class CachedThreadPoolTest&#123; psvm&#123; ExecutorService exec = Executors.newCachedThreadPool(); for(20 times) &#123; exec.execute(new WorkTask()); &#125; exec.shutdown(); &#125;&#125;//构造方法 参数 （线程数 最大线程数 时间片 单位时间 阻塞队列）public static ExecutorService newCachedThreadPool()&#123; return new ThreadpoolExecutor(0,Integer.MAX_VALUE,60L,TimeUnit.SECONDS,new Sysnchronous&lt;Runnable&gt;());&#125; FixedThreadPool 有界线程池 1234567891011121314public class FixedThreadPoolTest&#123; psvm&#123; ExecutorService exec = Executors.newFixedThreadPool(3); for(20 times) &#123; exec.execute(new WorkTask()); &#125; exec.shutdown(); &#125;&#125;public static ExecutorService newFixedThreadPool(int nThreads)&#123; return new ThreadPoolExecutor(nThreads, nThreads,0L, TimeUnit.MILLISECONDS,new LinkedBlockingQueue&lt;Runnable&gt;());&#125; SingleThreadExecutor 单一线程池 12345678910111213public class SingleThreadPoolTest&#123; psvm&#123; ExecutorService exec = Executors.newSingleTheadExecutor(); for(20 times) &#123; exec.execute(new WorkTask()); &#125; exec.shutdown(); &#125;&#125;public static ExecutorService newSingleThreadExecutor() &#123; return new FinalizableDelegatedExecutorService (new ThreadPoolExecutor(1, 1,0L, TimeUnit.MILLISECONDS,new LinkedBlockingQueue&lt;Runnable&gt;())); ScheduledThreadPool 定时周期 1234567public class ScheduledThreadPool&#123; psvm&#123; ExectorService exec = new Exector.newScheduledThreadExecutor(3); exec.execute(new WorkTask()); exec.shutdown(); &#125;&#125; 线程生命周期 新建 new创建线程 -&gt; JVM分配内存 &amp; 初始化成员变量的值。 就绪 线程对象调用start() 创建方法调用栈 &amp; 程序计数器 等待调度运行。 运行 处于就绪状态线程获得CPU，开始执行run（）方法的线程执行体。 阻塞 等待阻塞 run线程 执行 o.wait() jvm 会把线程放进等待队列 同步阻塞 run线程 想获取对象的同步锁，该锁被别的线程占用，jvm把线程放入锁池中（lock pool） 其他阻塞 Thread.sleep || t.join() || 发出IO请求 死亡 正常结束 run() || call() 方法执行完成 异常结束 线程抛出异常 调用stop stop() 乐观锁 &amp; 悲观锁 容器并发CopyOnWrite容器当我们向容器中添加元素，先copy该容器，把数据添加到copy容器中，再将数组引用指向容器。 实现线程安全： volatile修饰数组引用：确保数组内存可见性。【内存可见】-》 copy数组引用。 对容器修改操作同步。同一时刻只有一条线程修改容器 修改容器复制容器：修改操作都在新数组上，原数组可以放心读。 优点 并发读，实现读写分离 （当前容器不会添加任何元素） 无需加锁 缺点 内存占用，使用两个容器 只能保证数据最终一致性，无法保证实时性 使用场景读多写少，且不要求实时性 ConcurrentHashMap线程安全的HashTable改进版（一个线程访问，其他统统阻塞），而ConcurrentHashMap实现分段锁机制。 分段锁原理ConcurrentHashMap由多个Segment构成，每个Segment都包含一张哈希表。每次操作只将操作数据所属的Segment锁起来，从而避免将整个锁住。 每个Segment守护一个HashEntry数组的元素，当对hashEntry数组数据修改是，必须先获取对应的Segment锁（就是分段锁机制） ConcurrentHashMap内部包含了Segment数组，而每个Segment又继承自ReentrantLock，因此它是一把可重入的锁。 锁机制 脏读：a事务 读到 b事务 未提交的数据 ​ 解决 修改-&gt;排它锁，事务提交才释放，读取 -&gt;共享锁 共享锁 （很多人可以读） 【有人想修改】 -》 排它锁 ，修改完毕后，其他人重新读数据时发现已经不同 ，（他运行事务未提交就释放共享锁） 导致不能避免 不可重复读 幻读： 同一事务，同样的操作读取两次，发现多了几条或者少了几条。 新增 删除的打扰 ​ 说明： a事务 修改全表数据行， b事务插入一条新数据 a事务发现还有一条没有修改 ，就像发生幻觉一样。 事务T1：查询表中所有记录 --&gt;事务T2：插入一条记录 --&gt;事务T2：调用commit进行提交事务T1：再次查询表中所有记录 此时事务T1两次查询到的记录是不一样的，称为幻读。 ​ 解决： 采用范围锁，锁定检索范围只读。 不可重复读： 统一事务读取两次，发现内容不同 ​ 原因：执行select不加读锁（别人就改了） ​ 解决： 推迟事务2执行，知道事务1提交或回退。 在事务提交时检查事务的顺序性，可以让事务2先提交，事务1后提交时，如果顺序是（1-&gt;2)则事务1会回退重读 (2 -&gt; 1) 那没事了 读取数据加 共享锁 修改数据加排它锁 都是 事务提交才释放锁 丢失修改 a事务读取数据，更新数据 b事务读取数据 更新数据 ，a先提交 ，b后提交 ，a的修改操作丢失了 解决+ 排它锁 事务隔离五种级别： TRANSACTION_NONE 不使用事务。 TRANSACTION_READ_UNCOMMITTED 允许脏读。 TRANSACTION_READ_COMMITTED 防止脏读，最常用的隔离级别,并且是大多数数据库的默认隔离级别。 TRANSACTION_REPEATABLE_READ 可以防止脏读和不可重复读。 TRANSACTION_SERIALIZABLE 可以防止脏读，不可重复读取和幻读，（事务串行化）会降低数据库的效率。 乐观锁CAS &amp; 悲观锁 数据库 悲观锁 for update 行级锁 乐观锁 version字段 比较上次版本号 如果同 更新成功 ，不同，再（重复读)读 比较 写 jdk 悲观锁 sync 乐观锁 compose &amp; Swap 原子类 内部使用CAS实现 思想 业务场景&amp;实现方式 乐观锁 认为读多写少，遇到并发的可能性低，写数据线查看对应的版本号，自己加锁操作，之后比较版本号是否一致，之后写入。 CAP 高一致性c：分布式系统备份中，数据是否同一时刻都一直 高可用性a：集群节点故障，整体是否还能响应客户端请求 分区容忍性p：对通信时限的要求， 一致性算法Paxos决议达成一致想当learners的proposer去acceptor投简历 角色：Proposer、Acceptor、Learners 阶段： 准leader确定 【proposer的N提案proposer请求，acceptor的v承诺】。 leader确定 【proposer的多数票选[N,V]acceptor请求 ，送给acceptor，则答应成为learners】。 ZAB原子消息广播协议有王国的带纸和广播的人 三大步骤 崩溃恢复：leader服务器崩溃，ZAB进入恢复状态，选举新的leader 数据同步：新leader会与过半以上服务器数据同步，ZAB退出崩溃恢复模式，进入消息广播 消息广播：有新的服务器加入，会自动找到消息广播的leader，与它进行数据同步工作，进leader服务器数据发送到其他服务器。 Raft### Java网络通讯NIONIO分为阻塞和分蛛丝啊量 数据库原理垂直切分&amp;水平切分垂直切分： :+1:表与表的io争夺 :no_entry:单表数据量增长压力 水平切分： 相反 12345678产品表 订单表 用户表 10w steady 200w UP 100w UP垂直切分： [server] | 产品表 订单表 | 用户表[server]水平切分： | -男 -----link--- - 已完成订单 [server] | 用户表 订单表 - 未完成订单 [server] | -女 [server] 索引索引种类 普通索引 index[userName] on (username(length)) 唯一索引 unique [indexName] on (username(length)) 索引列唯一 主键索引 primary key (id) 组合索引 name, city, age建到一个索引里 alter table mytable add index name_city_age(name(10), city, age); 相当于 mysql组合最左前缀 username,city,age username,city ：select * from mytable where username =”admin” city =”cc” username: select * from mytable where username=‘ss” 索建立时机 &lt;，&lt;=，=，&gt;，&gt;=，BETWEEN，IN，以及某些时候的LIKE才会使用索引 city &amp; age 建立索引 ，mytable 的username也要建立 123select t.Namefrom mytable t left join mytable mon t.Name = m.username where t.age = 20 and t.city = &quot;ss&quot; 索引不足 up 查询速度 down 表更新速度 ：insert 、update delete 需要维护主表之外还要同步保存索引文件，在聚集索引层面上说就是需要维护这个平衡树，每次的更新都会破坏原有树的状态，需要重新梳理树的结构，如果数据量很大，更新表可能就开始变得困难 ​ 聚集索引 （主键索引） ​ 非聚集索引 （单一索引 普通索引 组合索引） 可以通过非聚集索引所提供的记录查到对应的聚集索引（主键） 然后再用主键查。 无论有什么方式查表，都会利用主键以聚集索引的方式来定位数据，聚集索引（主键）是通往真实数据的唯一通道。 索引占用磁盘索引文件 12345678910create table mytable(ID int not null, #index [indexName] (username(length)) username varchar(16) not null city VARCHAR(50) NOT NULL, age INT NOT NULL );#indexcreate index indexName on mytable(username(length));alter mytable add idnex [indexName] on (username(length))drop index [indexName] on mytable MyISAM&amp;InnoDB引擎区别 事务 锁InnoDB 支持 外键、事务、行级锁 。MyISAM（不支持） 读写性能MyISAM读性能up，写性能up（除了有索引update的InnoDB) 索引数据MyISAM索引和数据分开，索引压缩 -》非聚集索引 b+数检索算法检索，找到对应的数据域的值（是主键的地址） ；InnoDB索引和数据时紧密联系 delete table mytabl InnoDB不会重新建立表， 是一行一行删 锁表 锁行InnoDB可能锁全表（而不是行级锁）当 like%aaa% 扫不确定范围 ； 和 where 条件没有主键时。 使用 执行大量的INSERT或UPDATE操作需要事务 ： InnoDB 大量的SELECT查询读多写少的项目,可以考虑使用MyISAM 三范式 原子性 2NF 一张表里描述了两个事情：学生信息、课程信息 姓名、年龄 -&gt; 学号 学分 -&gt; 课程 3NF 某个字段必须是主键 学院地址、学校电话 -&gt; 学院 学院 -》学号 其他== equal hashcode区别 == equal 都是判断引用地址是否相同 string equal 就是 1.判断是否为string类型 2.遍历每个char字符 重写equal可以判断内容是否相同 hashcode 更多应用在set 无重复数字，（每增加一个 就要和n-1个数字equal的缺点）。 每个数都有对应的 hashcode 映射到哈希表中，（每个数有对应的坑和他的坑号码） 比较只要看他手上的坑号码是否相同，不同就不等，同就equal判断内容。 接口和抽象类 抽象类通过继承来使用 接口通过实现类使用 抽象类可以提供抽象方法和实现方法 接口类实现方法需要用default定义 lamdba表达式 强制类型转换错误12short s1 = 1; 把 整数1 转换为 short类型s1 = 1 + s1 ; error 右边会 1+ s1转为int类型 强制转换成s1 short发生错误 length方法 数组长度 .length 属性 String获取长度 length（）方法 集合获取长度 size（）方法 文件获取长度 length（）方法 介绍数据库索引1、索引的种类4，索引生效时刻，主键、组合，普通，聚集索引和非聚集索引 线程安全问题线程安全需要你使多个线程安全有序的访问修改同一个资源，而不会造成冲突。（修改丢弃、脏读、不可重复读]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剑指office算法]]></title>
    <url>%2F2019%2F08%2F27%2Foffice%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[不修改数组找出重复的数字二分+抽屉原则123456789101112131415161718192021222324/**给定一个长度为 n+1 的数组nums，数组中所有的数均在 1∼n 的范围内，其中 n≥1。请找出数组中任意一个重复的数，但不能修改输入的数组。样例给定 nums = [2, 3, 5, 4, 3, 2, 6, 7]。返回 2 或 3。*/class Solution &#123;public: int duplicateInArray(vector&lt;int&gt;&amp; nums) &#123; int l = 1, r = nums.size() -1; while(l &lt; r)&#123; int mid = r + l &gt;&gt; 1; int s = 0; for(auto x : nums) s += x &gt;=l &amp;&amp; x &lt;= mid; //if(x &gt;=l &amp;&amp; x &lt;= mid) s++ 或者是 s+= (x &gt;=l &amp;&amp; x &lt;=r) if(s &gt; mid - l + 1) r = mid; else l = mid + 1; &#125; return r; &#125;&#125;; 重建二叉树二叉树递归12345678910111213141516171819202122232425262728293031323334353637383940/**给定：前序遍历是：[3, 9, 20, 15, 7]中序遍历是：[9, 3, 15, 20, 7]返回：[3, 9, 20, null, null, 15, 7, null, null, null, null]返回的二叉树如下所示： 3 / \ 9 20 / \ 15 7 * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: map&lt;int,int&gt; hash; vector&lt;int&gt; preorder, inorder; TreeNode* buildTree(vector&lt;int&gt;&amp; _preorder, vector&lt;int&gt;&amp; _inorder) &#123; preorder = _preorder, inorder = _inorder; for(int i = 0; i &lt; inorder.size(); i++) hash[inorder[i]] = i; return dfs(0,preorder.size() -1,0,inorder.size() -1); TreeNode* dfs(int pl,int pr,int il, int ir)&#123; if(pl &gt; pr) return nullptr; int k = hash[root -&gt; val]; auto left = dfs(pl+1, pl + k -il, il, k -1); auto right = dfs(pl+ k -il +1, pr, k + 1, ir); root-&gt;left = left, root-&gt;right = right; return root; &#125; &#125;&#125;; 二叉树的下一个节点二叉树操作123456789101112131415161718192021222324252627282930313233343536373839404142/**给定一棵二叉树的其中一个节点，请找出中序遍历序列的下一个节点。注意：如果给定的节点是中序遍历序列的最后一个，则返回空节点;二叉树一定不为空，且给定的节点一定不是空节点；样例假定二叉树是：[2, 1, 3, null, null, null, null]， 给出的是值等于2的节点。则应返回值等于3的节点。解释：该二叉树的结构如下，2的后继节点是3。 2 / \1 3*//** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode *father; * TreeNode(int x) : val(x), left(NULL), right(NULL), father(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: TreeNode* inorderSuccessor(TreeNode* p) &#123; if( p -&gt; right) &#123; while(p -&gt; left) p = p -&gt; left; return p; &#125; while( p -&gt; father &amp;&amp; p == p -&gt; father -&gt; right) p = p -&gt; father; return p -&gt; father; &#125;&#125;; ## 用两个栈实现队列栈操作123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354class MyQueue &#123;public: stack&lt;int&gt; stk,cache; /** Initialize your data structure here. */ MyQueue() &#123; &#125; /** Push element x to the back of queue. */ void push(int x) &#123; stk.push(x); &#125; void copy(stack&lt;int&gt; a, stack&lt;int&gt;b)&#123; while(a.size())&#123; b.push(a.top()); a.pop(); &#125; &#125; /** Removes the element from in front of queue and returns that element. */ int pop() &#123; copy(stk,cache); int result = cache.top(); cache.pop(); copy(cache,stk); return result; &#125; /** Get the front element. */ int peek() &#123; copy(stk,cache); int result = cache.top(); copy(cache,stk); return result; &#125; /** Returns whether the queue is empty. */ bool empty() &#123; return stk.empty(); &#125;&#125;;/** * Your MyQueue object will be instantiated and called as such: * MyQueue obj = MyQueue(); * obj.push(x); * int param_2 = obj.pop(); * int param_3 = obj.peek(); * bool param_4 = obj.empty(); */ 斐波那契数列问题1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950/**定义 a0=1a0=1, a1=1a1=1, an=an−1+an−2an=an−1+an−2，求 anan 是多少。为了避免考虑整数溢出问题，我们求 an%pan%p 的值，p=109+7p=109+7。*/const int MOD = 1000000007;// 1.递归int f(int n)&#123; if(n &lt;= 1) return 1; return (f(n-1) + f(n-2)) % MOD;&#125;//2.记忆化搜索//开一个大数组记录中间结果 如果状态被计算过，直接查表，否则递归计算 //递归计算，递归层数太多会爆栈const int N = 100000, MOD = 1000000007;int a[N];if f2(int n)&#123; if(a[n]) return a[n]; if(n &lt;= 1) return 1; a[n] = f2(n - 1) + f2(n - 2); a[n] %= MOD; return a[n];&#125;//3.递推//开个大数组，记录每个数的值，用循环递推计算，//计算n个状态 则开一个长度是 n 的数组，内存将成为瓶颈const int N = 100000, MOD = 1000000007;int f3(int n)&#123; a[0] = a[1] = 1; for(int i = 2; i &lt;= n; i++) &#123; a[i] = a[i -1] + a[i - 2]; a[i] %= MOD; &#125; return a[n];&#125;//4.递归+滚动变量//递推优化 记录前两项值 时间复杂度o(n) 变成 空间复杂度变成0（1）const int MOD = 1000000007;int f4(int n)&#123; int x,y,z; x = y = 1; for(int i = 2; i &lt;= n; i++)&#123; z = (x + y) % MOD; x = y; y = z; &#125;&#125; 最后一种使用矩阵运算+快速幂 快速幂模板$$m^k\pmod p$$ 1234567891011//下次分析//时间复杂度 O(logk)。int qmi(int m, int k, int p)&#123; int res = 1 %p, t = m; while(k)&#123; if(k&amp;1) res = res * t %p; t = t * t % p; k &gt;&gt;=1; &#125;&#125; 旋转数组的最小数字二分12345678910111213141516171819202122232425262728293031323334353637383940/**把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。输入一个升序的数组的一个旋转，输出旋转数组的最小元素。例如数组&#123;3,4,5,1,2&#125;为&#123;1,2,3,4,5&#125;的一个旋转，该数组的最小值为1。数组可能包含重复项。注意：数组内所含元素非负，若数组大小为0，请返回-1。样例输入：nums=[2,2,2,0,1]输出：0*///粗暴法class Solution &#123;public: int findMin(vector&lt;int&gt;&amp; nums) &#123; if(nums.empty()) return -1; int mix = nums.at(0); for(auto x : nums)&#123; if(x &lt; mix) mix = x; &#125; return mix; &#125;&#125;;//二分法class Solution&#123; public: int findMid(vector&lt;int&gt;&amp; nums)&#123; int n = nums.size() - 1; if(n &lt; 0) return -1; while( n &gt;0 &amp;&amp; nums[0] == nums[n]) n--; if(nums[0] &lt; nums[n]) return nums[0]; int l = 0, r = n; while(l &lt; r )&#123; int mid = l + r &gt;&gt; 1; //[l,mid] [mid+1,r] if(nums[0] &lt; nums[mid]) l = mid+1; else r = mid &#125; return nums[r]; &#125;&#125; 数组中只出现一次的数字O异或位运算123456789101112131415161718192021/**数组中数字均有重复，只有两个数分别都唯一，找出这两个数输入:[2,5,2,7,3,2,3]输出:[5,7]思路： 数组所有数异或之后，[异或 同：0 不同：1]剩下两个数， 此时 5 7 0101 异或 0111 = 0010 用0001 和 0010 异或 如果不为1 ，0001 左移一位，步长++(jud &lt;&lt; 1); 之后就把 0101 和 0111 区分开来 if(jud ^ nums) x ^= nums; else y ^= nums;*/class Solution &#123;public: int singleNumber(vector&lt;int&gt;&amp; nums) &#123; int res = 0; for(auto x : nums) res ^= x; return res; &#125;&#125;; 数组中只出现一次的数字I异或位运算123456789101112131415161718/** 136给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。说明：你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？示例 1:输入: [2,2,1]输出: 1示例 2:输入: [4,1,2,1,2]输出: 4思路： 每个数相互异或 得到的那个数就是只出现一次的数*/class Solution &#123;public: int singleNumber(vector&lt;int&gt;&amp; nums) &#123; &#125;&#125;; 数组中只出现一次的数字II异或位运算1234567891011121314151617181920212223242526272829303132/** 137给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现了三次。找出那个只出现了一次的元素。说明：你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？示例 1:输入: [2,2,3,2]输出: 3示例 2:输入: [0,1,0,1,0,1,99]输出: 99思路： [ 0010, 0010, 0011, 0010 ]右移0位[ xxx0, xxx0, xxx1, xxx0 ]异或[ 0001 ] = [ 0, 0, 1, 0 ] =&gt;sum= 1 ;cout += sum % 3 = 1;右移1位[ xxx1, xxx1, xxx1, xxx1 ]异或[ 0001 ] = [ 1, 1, 1, 1 ] =&gt;sum= 4 ;cout += sum % 3 = 1+ sum = 2;右移2位[ xxx0, xxx0, xxx0, xxx0 ]异或[ 0000 ] = [ 0, 0, 0, 0 ] =&gt;sum= 0 ;cout += sum % 3 = 0+ sum = 2;右移3位[ xxx0, xxx0, xxx0, xxx0 ]异或[ 0000 ] = [ 0, 0, 0, 0 ] =&gt;sum= 0 ;cout += sum % 3 = 0+ sum = 2;输入为 0001左移0位 + 0001左移1位 ；*/class Solution &#123;public: int singleNumber(vector&lt;int&gt;&amp; nums) &#123; int res = 0; for(int k= 0; k &lt; 32; k++)&#123; int mask = 1 &lt;&lt; k ; int cout = 0; for(auto num : nums)&#123; if(num &amp; mask) cout++; &#125; if(cout % 3 != 0) res |= mask; &#125; return res; &#125;&#125;; 子串变位词(有效的字母异位词)1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677/**给定两个串a和b，问b是否是a的子串的变位词例：a = hello , b = lel,lle,ello 都是 true b = elo 是false思路:滑动窗口 + 维护数组array[26] = 0for(int index : b.size() -1) array[b[index] - 'a'] ++; onZero++; a['l'] a['e' = 4] onZero = 3; 2 1for(int index : a.size() -1)&#123; array[a[index] - 'a'] -- == 0; onZero --; //if(onZero == 0) -&gt; true; a['h'] a['e'] a['l'] -1 0 1 array[a[index] - 'a'] -- == -1; onZero ++; index 会滑动&#125;return false;*//* 普通版*/class Solution&#123; public: bool isAnagram(String s, String t)&#123; if(s.length() != t.length) return false; int a[26] = &#123;0&#125;; int length = sizeof(a)/sizeof(a[0]); for(int i =0; s[i] != '\0'; i++)&#123; a[s[i] - 'a']++; a[t[i] - 'a']--; &#125; for(int i = 0 ; i &lt; length ; i++) if(a[i] != 0) return false; return true; &#125; &#125;// 升级 窗口滑动int nonZero = 0;for(int i =0; i &lt; lenb; ++i) if(++num[b[i] - 'a'] == 1) ++nonZero;//非0出现//找子串for(int i = 0; i &lt; lenb; ++i)&#123; int c= a[i] - 'a'; --num[c]; if(num[c] == 0) --nonZero; else if(num[c] == -1) ++nonZero;&#125;if(nonZero == 0 ) return true;//滑动窗口 向右移动// new a[i-lenb +1 , i]// old a[i-lenb , i-1]// 扔 a[i-lenb] 加入a[i]for(int i = lenb; i &lt; lena; i++)&#123; int c = a[i - lenb] - 'a'; ++num[c]; if(num[c] == 1) ++nonZero; else if(num[c] == 0) --nonZero; c = a[i] -'a'; --num[c]; if(num[c] == 0) --nonZero; else if(num[c] == -1) ++nonZero; if(nonZero == 0) return true;&#125;//小补充num.empty();num.at(); = num[i]num.push_back();vector&lt;int&gt; v ;v.reserve(10); 矩阵中的路径123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657/**请设计一个函数，用来判断在一个矩阵中是否存在一条包含某字符串所有字符的路径。路径可以从矩阵中的任意一个格子开始，每一步可以在矩阵中向左，向右，向上，向下移动一个格子。如果一条路径经过了矩阵中的某一个格子，则之后不能再次进入这个格子。注意：输入的路径不为空；所有出现的字符均为大写英文字母；样例matrix=[ ["A","B","C","E"], ["S","F","C","S"], ["A","D","E","E"]]str="BCCE" , return "true" str="ASAE" , return "false"*/class Solution &#123;public: bool hasPath(vector&lt;vector&lt;char&gt;&gt;&amp; matrix, string str) &#123; for(int i =0 ; i &lt; matrix.size(); i++) &#123; for(int k = 0; k &lt; matrix[i].size(); k++) &#123; if(dfs(matrix, str,0, i , k)) return true; &#125; &#125; return false; &#125; bool dfs(vector&lt;vector&lt;char&gt;&gt;&amp; matrix, string &amp;str, int u, int x, int y )&#123; //验证是否为当前是否对应 if( matrix[x][y] != str[u] ) return false; //长度一致 返回 true if(u == str.size() -1 ) return true; //走的范围 int dx[4] = &#123;-1,0,1,0&#125;, dy[4] = &#123;0,1,0,-1&#125;; char t = matrix[x][y]; //标记 此时这个点 为* （说明可能是其中一个点） matrix[x][y] = '*'; for(int i = 0; i &lt; 4; i++)&#123; int a = x + dx[i], b = y + dy[i]; //只要走不超过矩阵访问 继续走 注意 a b 的范围 if(a &gt;= 0 &amp;&amp; a &lt; matrix.size() &amp;&amp; b &gt;= 0 &amp;&amp; b &lt; matrix[a].size())&#123; if (dfs(matrix, str, u + 1, a, b)) return true; &#125; &#125; //该点 周围四角均不符合条件 把 * 恢复成 原来样子 matrix[x][y] = t; return false; &#125;&#125;;]]></content>
      <categories>
        <category>c++</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ks8概念总结]]></title>
    <url>%2F2019%2F08%2F13%2FKS8%E6%A6%82%E5%BF%B5%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[KS8概念总结模型图技术迭代部署大规模集群 模型 架构 实现高可用架构三大指标 高可用、高性能、高并发 Zookeeper 负载均衡：实现轮询机制。防止阻塞 集群：必须实现数据同步，Redis 高可用：一直可用，实现崩溃恢复 A（down &amp; resume) B(up) C ks8高可用集群搭建节点配置 步骤： 关闭交换空间 避免开机启动交换空间 关闭防火墙 配置 DNS 安装 Docke 配置 Docker 加速器 安装 kubeadm，kubelet，kubectl 同步时间:时间要统一 配置 IPVS 配置内核参数\ 修改 cloud.cfg 是修改hostname 单独节点 配置 IP 配置主机名 安装 HAProxy （高可用）+ Keepalived（负载均衡） Keepalived概述ks8 Master阶段运行组件 kube-apiserver:提供资源操作的唯一入口（提供认证、授权、访问控制、api注册和发现) kube-scheduler：负责资源调度 ，将pod调度到相应机器上。 kube-controller-manager：负责维护集群状态（故障检测、自动扩展。。。） Keepalived当master挂了，将其他slaver接上去 实现图解 部署 Kubernetes 集群 初始化 Master 加入 Master 节点 加入 Node 节点 验证集群状态 验证高可用注意 重启之后ipvs要重新执行一哈 问题解决Node无法加入集群替换 Calico（网络插件） 网段为我们虚拟机不重叠的网段（这里用的是 Flannel 默认网段） 如果Calico网段与master、slaver网段重叠就会导致Node无法加入集群。 ks8重置 删除kubectl配置 启动ipvs 导出并修改配置文件 改calico网段 kubeadm初始化 配置kubectl 下载Calico 配置文件并修改 611 行 /name: CALICO_IPV$POOL_CIDR 的value 直接应用本地Calico 加入Master结点（最后 配置mkdir babbalala~~ dubectl get node) 通过资源配置运行容器(部署容器)测试启动顺序 Pod Deployment 内部访问 Service 外部访问机制 12345678910111213141516171819202122232425262728293031kubectl get node #结点状态master01: vi /kubernetes/yml/nginx-deployment.yml #设置deploymentkubectl create -f nginx-deployment.ymlkubectl get pod #查看podkubectl get deployment #看看deployment 开两个实例master01: vi /kubernetes/yml/ nginx-service.yml #设置servicekubectl get service #查看service端口： 80：30066 （30066指的是node 的pod暴露30066端口，再由pod映射到nginx 的80端口）kubectl describe service nginx-http #下面NodePort: 30066/TCP#使用LoadBalancer master slaver 端口都暴露master01：30066master02：30066slaver01：30066slaver02: 30066kubectl delete -f nginx-service.yml #停掉#想要把30066改成80端口vi /kubernetes/yml/ nginx-service.ymlprots: -prot: 80 #Service 端口 targetPort: 80 #Pod 端口 将Service暴露端口转发到Pod端口上 nodePort: 80 # 本来是30066 但是报错 他的范围30000-32767kubectl create -f nginx-service.yml #重开#解决办法vi /etc/kubernetes/manitestls/kube-apiserver.yml#增加配置--service-node-prot-range=2-65545#ks8重启 或者 他自动重启#验证kubectl create -f nginx-service.ymlkubectl describe service nginx-http Ingress统一访问入口ClusterIP服务内部访问方式：外部proxy模式访问内部 123kubectl get service type ClusterIP 三种外部访问方式NodePort在所有节点（虚拟机）上开放一个特定端口 每个端口一种服务 默认模式（官方不推荐） 调试的时候用 LoadBalancer在NodePort加了负载均衡 Ingress扮演智能路由 或 集 群入口 （类似API网关） 例如：部署Tomcat只允许在内网访问，需要Ingress提供反向代理功能路由到Tomcat上 部署Tomcat tomcat.yml（Devlopment+Service） ClusterIP设置 watch kubectl get pods # 查看运行状态 kubectl get deployment kubectl get service kubectl describe service tomcat-http 没有nodeport 限制外网访问 下载Nginx Ingress Controller 配置文件 &amp; 修改 hostNetwork: true kubectl get pods -all -namespaces 多了 ingress-nginx 部署ingress -&gt; ingress.yml kubectl get pods -n ingress-nginx -o wide ip: 192.168.141.161 SwitchHosts : 192.168.141.161 域名 数据持久化NFS+PV/PVC NFSRPC通信，分布式文件系统 部署 安装NFS服务端 安装NFS客户端 验证NFS服务 PV和PVC持久卷提供者 持久卷消费者 NFS网络方案 pv：规格集群资源 pvc：分配集群资源 create pv.yml pvc.yml 部署mysql 8 连接pv pvc 出现问题：没有个性化配置 ConfigMap用来存储配置文件的ks8资源对象，放在etcd内，一种外挂配置。解耦 即：可是用ConfigMap配置MYSQL Dashboard运行界面 CI/CD环境： java git mvn]]></content>
      <tags>
        <tag>分布式</tag>
        <tag>kubernetes</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[时间算法对应使用算法]]></title>
    <url>%2F2019%2F08%2F11%2F%E6%97%B6%E9%97%B4%E7%AE%97%E6%B3%95%E5%AF%B9%E5%BA%94%E4%BD%BF%E7%94%A8%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[时间算法对应使用算法1s 2s c++:指令执行次数：10^8 n &lt;=30, 指数级别； dfs+ 剪枝 n &lt;= 100 n^3 floyd]]></content>
      <categories>
        <category>c++</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RabbitMQ]]></title>
    <url>%2F2019%2F08%2F11%2FRabbitMQ%2F</url>
    <content type="text"><![CDATA[RabbitMQ控制台 用户 数据库 授权 Overview Ports and contexts amqp协议 clustering http Connections Channels Exchanges Queues Admin 简单队列示例RabbitMQ消息队列1234567891011121314151617181920212223 //获取MQ连接的工具类public class ConnectionUtiles&#123; public static Connection getConnection()&#123; //连接工厂 ConnectionFactory factory = new ConnectionFactory(); //设置服务地址 factory.setHost("127.0.0.1"); //端口AHQP 5672 factory.setPort(5672); //vhost facotry.setVirtualHost("/newMySql"); //用户名 factory.setUsername("miki"); //密码 facotry.setPassword("miki666"); //获取连接 return factory.newConnection(); &#125; 生产者1234567891011121314151617181920public class Send&#123; private static final String QUEUE_NAME = "test_simple_queue"; public static void main(String[] args)&#123; //拿到连接 Connection connection = ConnectionUtils.getConnection(); //创建通道 Channel channle = connection.createChannel(); //队列 声明 channel.queueDeclare(QUEUE_NAME,false,false,false,null); //发送 String msg = "hello simpel"; channel.basePublish("",QUEUE_NAME，null,msg.getBytes()); //关闭 channel.close(); conneciton.close(); &#125;&#125; 消费者12345678910111213141516171819202122232425262728293031323334353637383940public class Recv&#123; private static final String QUEUE_NAME = "test_simple_queue"; public static void main(String[] args)&#123; //拿到连接 Connection connection = ConnectionUtils.getConnection(); //创建通道 Channel channle = connection.createChannel(); //队列 声明 channel.queueDeclare(QUEUE_NAME,false,false,false,null); //=============老版本==================================================== //定义队列的消费者 QueueingConsumer consumer = new QueueingConsumer(channel); //监听 channel.basicConsumer(QUEUE_NAME,true,consumer); while(true)&#123; Doliver dalivery = consumer.nextDelivery(); String msgString = new String(dalivery.getBody()); sout(msgString); &#125; //===================老版本============================================= //===================新版本============================================= //观察者模式 队列有数据 消费者DefaultConsumer lamdba -&gt; channel 回调 handleDelivery //这里重写方法 new DefaultConsumer(channel)&#123; @Override public void handleDelivery(String consumerTag,Envelope envelope,BasicProperties properties,byte[] body) throws IOException&#123; String msg = new String(body,"utf-8"); scout(msg); &#125; &#125;; //消费者监听队列 阻塞 -》 android Button 监听事件 addListener channel.basicConsumer(QUEUE_NAME,true,consumer); //===================新版本============================================= &#125;&#125; 旧：监听消费者，while循环当有消息时return 新：channel被消费者监听时，回调 handleDelivery。 简单队列不足 耦合性高，生产者一一对应消费者，当出现多个消费者消费队列则不行；队列名变更，同时变更（生产者，消费者）。 消费者与业务结合，消费者接受消息进行处理，需要时间，就会在队列积压很多消息。 解决方案 工作队列：一个生产者对应多个消费者。 工作队列生产者12345678910111213141516171819202122public class Send&#123; private static final String QUEUE_NAME = "test_work_queue"; public static void main(String[] args) throws IOException,TimeoutException&#123; /* |--c1 * p --Queue--| * |--c2 */ //拿到连接 Connection connection = ConnectionUtils.getConnection(); //创建通道 Channel channle = connection.createChannel(); //队列 声明 channel.queueDeclare(QUEUE_NAME,false,false,false,null); for(int i = 0 ; i &lt; 50 ; i++ )&#123; String msg = "hello" + i; channel.basicPublish("",QUEUE_NAME,null,msg.getBytes()); Thread.sleep(i*10); // 抛出异常 &#125; channel.close(); connection.close(); &#125;&#125; 消费者more1234567891011121314151617181920212223242526272829303132public class Recv&#123; private static final String QUEUE_NAME = "test_work_queue"; public static void main(String[] args)&#123; //拿到连接 Connection connection = ConnectionUtils.getConnection(); //创建通道 Channel channle = connection.createChannel(); //队列 声明 channel.queueDeclare(QUEUE_NAME,false,false,false,null); //定义消费者 Consumer consumer = new DefaultConsumer(channel)&#123; @Override public void handleDelivery(String consumerTag,Envelope envelope,BasicProperties properties,byte[] body) throws IOException&#123; String msg = new String(body,"utf-8"); scout(msg); try&#123; Thread.sleep(2000); &#125;catch(InterruptedExceptin e)&#123; e.printStackTrace(); &#125;finally&#123; scout("done"); &#125; &#125; &#125;; boolean.autoAck =true; channel.basicConsumer(QUEUE_NAME,autoAck,consumer); &#125;&#125;//消费者2同理 简单队列不足 消费者1 &amp; 2 处理的消息都是一样：轮询分发（round-robin),无论谁忙谁闲，都不会都给，都是你一个我一个均摊分发。 解决方案使用basicQos（perfetch =1 ），消费者手动反馈（我已经做完了),即关闭自动应答ack改为手动。 公平分发Fair dispatch消费者加入回执操作123456789101112131415161718//需要发送确认消息public class Recv&#123; //~~~~~~~~获取连接~~~~~~~ //~~~~~~~获取channel~~~~~~~~ //~~~~~~~~声明队列~~~~~~~ //每个消费者发送确认消息之前，消息队列不发送下一个消息到消费者，一次只处理一次数据 channel.basicQos(1); //Channel channel = new DefaultConsumer(channel) ~~~finally&#123; scout("done"); //手动回执 channel.basicAck(envelope.getDeliveryTag(),fasle);&#125;&#125;; boolean autoAck = true; channel.basciConsumer(QUEUE_NAME,autoAck,consumer);&#125; 消息应答与持久化boolean autoAck = true; (自动确认模式)，一旦rebbit消息分发给消费者，消息就会从内存中删除。 坏处：如果消费者突然失败，就会丢失正在处理的消息。 boolean autoAck = false(默认，手动确认模式)，如果消费者突然失败，就会将消息交付给其他消费者。 Message acknowlegment ​ rabbitmq挂了，消息也会丢失 。解决方案-&gt;持久化 boolean durable = false channel.queueDeclare(QUEUE_NAME,durable) // 报错原因：把durable把false改true不可，是因为已经定义了QUEUE_NAME=test_work_queue，这个队列是未持久化，不可重新定义已存在的队列。重建一个队列（改名字）就可定义持久化。 工作队列缺点生产者发送的消息不能被消费者共享。 订阅模式交互机模型1234/* --&gt;|--queue --&gt;c1 * p --X--| * --&gt;|--queue --&gt;c2 */ 一个生产者多个消费者 每个消费者有自己的队列 生产者把消息发到交换机 队列要绑定到交换机 生产者发送 -&gt;消息 -&gt; 交换机 –&gt; 队列：实现一个消息被多个消费者消费。 例如：商品名字改了，搜索引擎改，前台变。 生产者123456789101112131415161718public class Recv&#123; private static final String EXCHANGE_NAME = "test_exchange_fanout"; public static void main(String[] args)&#123; //拿到连接 Connection connection = ConnectionUtils.getConnection(); //创建通道 Channel channle = connection.createChannel(); //队列 声明 交换机 channel.exchangeDeclare(EXCHANGE_NAME,"fanout"); //发送消息 String msg = "hello"; channel.basicPublish(EXCHANGE_NAME,"",null,msg.getBytes()); scout("Send" +msg); //close channel.close(); connection.close();&#125; 消费者one1234567891011121314151617181920212223242526272829303132public class Recv&#123; private static final String QUEUE_NAME = "test_exchange_fanout_email"; private static final String EXCHANGE_NAME = "test_exchange_fanout"; public static void main(String[] args)&#123; //拿到连接 Connection connection = ConnectionUtils.getConnection(); //创建通道 Channel channle = connection.createChannel(); //队列 声明 channel.queueDeclare(QUEUE_NAME,false,false,false,null); //绑定队列到交换机 channel.queueBind(QUEUE_NAME,EXCHANGE_NAME,"") //定义消费者 Consumer consumer = new DefaultConsumer(channel)&#123; @Override public void handleDelivery(String consumerTag,Envelope envelope,BasicProperties properties,byte[] body) throws IOException&#123; String msg = new String(body,"utf-8"); scout(msg); try&#123; Thread.sleep(2000); &#125;catch(InterruptedExceptin e)&#123; e.printStackTrace(); &#125;finally&#123; scout("done"); &#125; &#125; &#125;; boolean.autoAck =true; channel.basicConsumer(QUEUE_NAME,autoAck,consumer); &#125;&#125; 消费者two1234567891011121314151617181920212223242526272829303132public class Recv&#123; private static final String QUEUE_NAME = "test_exchange_fanout_sms"; private static final String EXCHANGE_NAME = "test_exchange_fanout"; public static void main(String[] args)&#123; //拿到连接 Connection connection = ConnectionUtils.getConnection(); //创建通道 Channel channle = connection.createChannel(); //队列 声明 channel.queueDeclare(QUEUE_NAME,false,false,false,null); //绑定队列到交换机 channel.queueBind(QUEUE_NAME,EXCHANGE_NAME,"") //定义消费者 Consumer consumer = new DefaultConsumer(channel)&#123; @Override public void handleDelivery(String consumerTag,Envelope envelope,BasicProperties properties,byte[] body) throws IOException&#123; String msg = new String(body,"utf-8"); scout(msg); try&#123; Thread.sleep(2000); &#125;catch(InterruptedExceptin e)&#123; e.printStackTrace(); &#125;finally&#123; scout("done"); &#125; &#125; &#125;; boolean.autoAck =true; channel.basicConsumer(QUEUE_NAME,autoAck,consumer); &#125;&#125; 现象：消费者1 消费者2 共享生产者发送的消息 交换机缺点一方面接收生产者消息，另一方面向队列推送消息。但是不能把消息交给指定queue 无交换机 channel.basicPublish(&quot;&quot;,&quot;&quot;) 改变 -&gt; 有交换机 没有路由 channel.exchangeDeclare(EXCHANGE_NAME,&quot;fanout&quot;) //不处理路由链 channel.basicPublish(EXCHANGE_NAME,&quot;&quot;) 路由模式路由模型12345/* | -error-&gt;|--queue --&gt;c1 * p --X ：key--| * | -info-&gt;| * |-warning-&gt;| --queue --&gt;c2 * | -error-&gt;| 生产者12345678910111213141516171819public class Recv&#123; private static final String EXCHANGE_NAME = "test_exchange_direct"; public static void main(String[] args)&#123; //拿到连接 Connection connection = ConnectionUtils.getConnection(); //创建通道 Channel channle = connection.createChannel(); //队列 声明 交换机 + 路由 direct channel.exchangeDeclare(EXCHANGE_NAME,"direct"); //发送消息 String msg = "hello"; String routingKey = "error"; channel.basicPublish(EXCHANGE_NAME,routingKey,null,msg.getBytes()); scout("Send" +msg); //close channel.close(); connection.close();&#125; 消费者123456789101112131415161718192021222324252627282930313233343536public class Recv&#123; private static final String QUEUE_NAME = "test_exchange_direct"; private static final String QUEUE_NAME = "test_queue_direct_i"; public static void main(String[] args)&#123; //拿到连接 Connection connection = ConnectionUtils.getConnection(); //创建通道 Channel channle = connection.createChannel(); //队列 声明 channel.queueDeclare(QUEUE_NAME,false,false,false,null); //绑定队列到交换机 channel.queueBind(QUEUE_NAME,EXCHANGE_NAME,"error"); //绑定多个 channel.queueBind(QUEUE_NAME,EXCHANGE_NAME,"info"); channel.queueBind(QUEUE_NAME,EXCHANGE_NAME,"warning"); //定义消费者 Consumer consumer = new DefaultConsumer(channel)&#123; @Override public void handleDelivery(String consumerTag,Envelope envelope,BasicProperties properties,byte[] body) throws IOException&#123; String msg = new String(body,"utf-8"); scout(msg); try&#123; Thread.sleep(2000); &#125;catch(InterruptedExceptin e)&#123; e.printStackTrace(); &#125;finally&#123; scout("done"); &#125; &#125; &#125;; boolean.autoAck =true; channel.basicConsumer(QUEUE_NAME,autoAck,consumer); &#125;&#125; 路由模式缺点生产者路由key只能一个。不能多个匹配，即不能多对多。 主题模式主题模型 模式匹配 #匹配一个或多个 *匹配一个 生产者：商品-&gt;发布（goods.add) 删除 修改 查询 消费者1：(goods.add) 消费者2：(goods.#) 生产者12345678910111213141516171819public class Recv&#123; private static final String EXCHANGE_NAME = "test_exchange_topic"; public static void main(String[] args)&#123; //拿到连接 Connection connection = ConnectionUtils.getConnection(); //创建通道 Channel channle = connection.createChannel(); //队列 声明 交换机 + 路由 direct channel.exchangeDeclare(EXCHANGE_NAME,"topic"); //发送消息 String msg = "商品 .."; String routingKey = "goods.add"; channel.basicPublish(EXCHANGE_NAME,routingKey,null,msg.getBytes()); scout("Send" +msg); //close channel.close(); connection.close();&#125; 消费者12345678910111213141516171819202122232425262728293031323334353637public class Recv&#123; private static final String QUEUE_NAME = "test_exchange_direct"; private static final String QUEUE_NAME = "test_queue_direct_i"; public static void main(String[] args)&#123; //拿到连接 Connection connection = ConnectionUtils.getConnection(); //创建通道 Channel channle = connection.createChannel(); //队列 声明 channel.queueDeclare(QUEUE_NAME,false,false,false,null); //绑定队列到交换机 channel.queueBind(QUEUE_NAME,EXCHANGE_NAME,"goods.add"); //消费者2--------------------------------------- channel.queueBind(QUEUE_NAME,EXCHANGE_NAME,"goods.#"); //消费者2--------------------------------------- channel.basicQos(1); //定义消费者 Consumer consumer = new DefaultConsumer(channel)&#123; @Override public void handleDelivery(String consumerTag,Envelope envelope,BasicProperties properties,byte[] body) throws IOException&#123; String msg = new String(body,"utf-8"); scout(msg); try&#123; Thread.sleep(2000); &#125;catch(InterruptedExceptin e)&#123; e.printStackTrace(); &#125;finally&#123; scout("done"); &#125; &#125; &#125;; boolean.autoAck =true; channel.basicConsumer(QUEUE_NAME,autoAck,consumer); &#125;&#125; 在路由的基础上，消费者多了匹配符，简化消费者用多个通道来对应queue。 即，主题模式更加符合模块化接收，（从一个管子变成口子） 消息确认机制（事务+confirm)通过持久化数据，解决消费者异常导致数据丢失问题。但是不知道消息发出去是否接收到。 两种解决方案 AMQP实现事务机制（类似mysql） Confirm模式 AMQP实现事务机制 txSelect:用于用户将当前channel设置成transation模式 txCommit：用于提交事务 txRoolback：回滚事务 生产者123456789101112131415161718192021222324252627 private static final String QUEUE_NAME = "test_queue_tx"; public static void main(String[] args)&#123; //拿到连接 Connection connection = ConnectionUtils.getConnection(); //创建通道 Channel channle = connection.createChannel(); //队列 声明 交换机 + 路由 direct channel.queueDeclare(QUEUE_NAME,false,false,false,null); //发送消息 String msg = "hello tx .."; try&#123; channel.txSelect(); channel.basicPublish("",QUEUE_NAME,null,msg.getBytes()); //------异常------ // int x = 1/0; //------异常------ channel.txCommit(); scout("Send" +msg); &#125;catch(Exception e)&#123; channel.txRollback(); scout("tx rollback"); &#125; //close channel.close(); connection.close();&#125; 消费者12345678910111213141516171819202122public class Recv&#123; private static final String QUEUE_NAME = "test_queue_tx"; public static void main(String[] args)&#123; //拿到连接 Connection connection = ConnectionUtils.getConnection(); //创建通道 Channel channle = connection.createChannel(); //队列 声明 channel.queueDeclare(QUEUE_NAME,false,false,false,null); //定义消费者 Consumer consumer = boolean.autoAck =true; channel.basicConsume(QUEUE_NAME,true,new DefaultConsumer(channel)&#123; @Override public void handleDelivery(String consumerTag,Envelope envelope,BasicProperties properties,byte[] body) throws IOException&#123; scout(new String(body,"utf-8")); &#125; &#125;); &#125;&#125; 缺点：事务的大量提交，会降低生产者的吞吐量。 Confirm模式实现原理]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>RabbitMQ</tag>
        <tag>消息队列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[oAth2(二)]]></title>
    <url>%2F2019%2F08%2F09%2FoAuth2%E6%A1%88%E4%BE%8B%2F</url>
    <content type="text"><![CDATA[oAuth2案例内存、jdbc存储令牌 AuthorizationServerConfiguration:认证client、secret 和授权码通过 提供资源 http://client:secret@localhost:8080/oauth/token= 授权码 WebSecurityConfiguartion：认证功能 提供授权码 文字流程：用户 -》web（账户） 获得授权码； 用户post：client_id:secret+授权码 获得 scope区域内的资源。 角色的权限访问控制 RBAC 角色 ACL 控制列表 ABAC 属性 PBAC 策略 来源：论文、社区、RFC6749 RBAC：最小权限、责任分离、数据抽象who（认证服务器）、what（权限针对的对象 &amp; 资源 授权服务器）、how(具体的权限) who:user what: 静态资源 功能操作，数据列 动态资源 数据、文章、相册、笔记 post 查看 新增 photos how： CRUD user role角色 permission权限 user_role role_permission 关系图： 模块图：]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>oAth2</tag>
        <tag>sso</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Gradle]]></title>
    <url>%2F2019%2F08%2F09%2FGradle%E6%A1%88%E4%BE%8B%2F</url>
    <content type="text"><![CDATA[Gradle案例Project &amp;&amp; taskGroovy基本语法构建任务&amp;运行123456789101112task hello&#123; doLast &#123; println 'Hello world' &#125;&#125;//改良task hello &lt;&lt; &#123; println 'Hello world'&#125;//命令行&gt; gradle -q helloHello world gradle 构建脚本+ 运行脚本 运行任务前要依赖的任务12345678910task "task$counter" &lt;&lt; &#123; println " I'm task number $counter"&#125;//加入依赖task0.dependsOn task2, task3&gt; gradle -q task0I'm task number 0I'm task number 2I'm task number 3 喝水需要有杯子和烧好的水 声明任务之间的运行顺序1234567891011121314151617181920212223242526task after(dependsOn: 'before') &lt;&lt; &#123; println 'after'&#125;task before &lt;&lt; &#123; println 'before'&#125;&gt; gradle -q after beforeaftertask hello &lt;&lt; &#123; println 'hello'&#125;hello.doFirst &#123; println 'ask:'&#125;hello.doLast &#123; println 'shank hands'&#125;hello &lt;&lt; &#123; println 'leave'&#125;// &lt;&lt; 是 doLast 简写// $hello.name 会出来 hello //获取当前任务的名字&gt;gradle -q hello 喝水前要拿杯子，喝完要洗杯子 任务参数化12345678task myTask&#123; ext.myProperty = "myValue"&#125;task printTaskProperty &lt;&lt; &#123; println myTask.myProperty&#125;&gt; gradle -q pritnTaskPropertymyValue 杯子的名字 Ant构建工具12345678910111213141516171819task loadfile &lt;&lt; &#123; def files = file('../antLoadfileResources').listFiles().sort() files.each &#123; File file -&gt; if (file.isFile())&#123; ant.loadfile(srcFile: file, property: file.name) println " *** $file.name ***" println "$&#123;ant.properties[file.name]&#125;" &#125; &#125; &#125;//遍历 ../antLoadfileResources 所有文件 打印出来&gt; gradle -q loadfile*** agile.manifesto.txt ***Individuals and interactions over processes and toolsWorking software over comprehensive documentationCustomer collaboration over contract negotiationResponding to change over following a plan*** gradle.manifesto.txt *** 脚本-&gt;任务管理+自动化 Java构建入门项目编译class、打包jar、运行javac gradle bulid: 编译测试代码，并生成含所有类和资源的jar文件。 clean：删除build的所有东西 assemble： 编译 &amp; 打包代码-&gt; 可执行文件 check：编译 &amp; 测试 外部依赖 提取 &amp; 放入 依赖 12345678910111213//加入依赖// commons-coolections 加入编译阶段// junit 加入到了测试编译阶段.dependencies&#123; compile group: 'commons-coolections', name: 'commons-collections', version: '3.2' testCompile group: 'junit', name: 'junit', version: '4.+' &#125;//远程仓库repositories&#123; maven&#123; url 'http://alibaba~~~~~/re~~/' &#125;&#125; 定制项目 项目名+版本号 定制 MANIFEST.MF 文件 1234567sourceCompatibility = 1.5version = '1.0'jar &#123; manifest &#123; attributes 'Implementation-Title': 'myfirstProject', 'Implementation-Version': version &#125;&#125; 发布JAR文件 本地仓库repos中 gradle uploadArchives命令发布jar文件 1234567uploadArchives&#123; repositories&#123; flatDir&#123; dirs 'repos' &#125; &#125;&#125; 合并123456789101112131415161718192021222324252627282930313233343536373839404142//------------------------------加入插件apply plugin: 'java'apply plugin: 'eclipse'//------------------------------//------------------------------ 自定项目名+版本号sourceCompatibility = 1.5version = '1.0'jar &#123; manifest &#123; attributes 'Implementation-Title': 'Gradle Quickstart', 'Implementation-Version': version &#125;&#125;//------------------------------//------------------------------ 远程仓库地址repositories &#123; mavenCentral()&#125;//------------------------------//------------------------------ 项目依赖dependencies &#123; compile group: 'commons-collections', name: 'commons-collections', version: '3.2' testCompile group: 'junit', name: 'junit', version: '4.+'&#125;//------------------------------//------------------------------测试时添加key valuetest &#123; systemProperties 'property': 'value'&#125;//------------------------------//------------------------------ 打包上传仓库uploadArchives &#123; repositories &#123; flatDir &#123; dirs 'repos' &#125; &#125;&#125; 多项目构建]]></content>
      <categories>
        <category>部署</category>
      </categories>
      <tags>
        <tag>gradle</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[sso单点登录]]></title>
    <url>%2F2019%2F08%2F09%2Fsso%E5%8D%95%E7%82%B9%E7%99%BB%E5%BD%95%2F</url>
    <content type="text"><![CDATA[Nginx nginx 服务器： 192.168.75.128：81 tomact1： 192.168.75.128：9090 tomcat2：192.168.75.128：9091 nginx IP:192.168.75.128:81 配置： listen: 80 ​ tomcat_pool: http://192.168.75.128:9090 ​ : http://192.168.75.128:9091 作用： 虚拟主机CDN /反向代理 SSO单点登录redis c语言 key-value 字符： json 散列：Map 列表：list 集合：Set 有序集合：HashSet 应用场景 缓存 分布式集群架构的session分离 （http无状态 cookie 有状态 session服务端 判断用户是谁) 好友列表 消息队列 不用 我们用专门的 排行榜 网站访问量 数据 数字自增 日期 毫秒 并发 yyymmddhhmmss+redis的自增数字 订单号的生成方案 Redis高可用解决方案 keepalived zookeeper sentinel 主要解决单点故障 应用 -&gt; sso单点登录 传统登录机制 session会话机制 通过 将token 存到客户端的cookie ，之后每次客户端请求时携带token值让客户端识别WhoAmI 缺陷 同源机制：必须在同源下才可以共享token 当创建多个不同服务器时（php/java/.net/) 所提供的session机制不同，会导致不识别 cookie不安全 SSO单点登录 解决上诉痛点 步骤： 查询用户信息 redis到mysql service层 获取cookie中的token的value，作为key查询Redis是否有value(用户名)：有(已经登陆过) 提供user。 无 继续 去数据库查询有无该用户信息 ,有，将username，password存到redis（第一次登陆)，无,返回null(未登录) sso登录服务 controller层 返回非null（且第一次登陆) 登录成功 用CookieUtil生成一个随机num，&lt;num,userId&gt;存放到Redis中（熔断了返回刷新重试)， &lt;token,num&gt;存放到客户端， -&gt; 登录成功 返回null -&gt; 登录失败/未登录 效果：通过redis实现统一的session管理，解决缺陷2，无论何种服务器，存储数据格式方案一致，token从客户端到服务端两次分离，解决cookie不安全（缺陷3)；同源机制可以通过nginx反向代理解决/Zuul网关。 th拦截器可以用vue判断json返回 是否执行跳转。 拦截器还有个拦截Config 拦截所有资源，去到下列拦截执行器中 123456789101112131415161718192021222324252627282930313233package com.admin.interceptor;public class WebAdminInterceptor implements HandlerInterceptor&#123; @Overrider public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler)&#123; //cookie 为空 一定没有登陆 -&gt;去单点登录 String token = CookieU ~~ response.senRedirect("http://login.html"); // 该常量可以放进config里面 return false; &#125; @Overrider public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handle, ModelAndView modeAndView)&#123; //cookie有，但是不一定登录 session里那数据 HttpSession session = request.getSession(); User user = session.getAttribute("user"); //局部会话 //user不为空 处于局部会话的已登录状态---------------------------- modelAndView.addObject("user",user); //提供给下一个跳转的有缘人 //user为空 处于未登录状态-------------------------------------- //Cookie 拿到的token ，value作为key去Redis查询 ，拿到loginCode 去mapper拿到完整user //如果loginCode不为空 -&gt; 已登录 创建局部会话，并把user存放到里面 request.getSession().setAttribute("user",user); //二次确认 user == null ; //直接重定向到登录系统 &#125; @Overrider public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handle, Execption ex)&#123; &#125;&#125; 1234567891011121314//出现问题//RedisService无法被自动注入 class InterceptorConfig implements WebMvcConfigurer&#123; @Bean WebAdminInterceptor webAdminInterceptor()&#123; return new WebAdminInterceptor(); &#125; @Override public void addIntercepotrs(InterceptorRegistry registry)&#123; registry.addIntercptor(new WebAdminInterceptor()) .addPathPatterns("/**") .excluedPathPatterns("/static"); &#125; &#125; 跨域：同源策略下的脚本安全问题，浏览器限制脚本只能在同源下执行，但是现在是微服务，可能位于不同ip/域名/端口，导致存在。 解决： CORS跨资源共享，浏览器自动完成，在header设置即可，关键在服务器实现CORS接口即可:-1:不支持老式浏览器 Jsonp 利用&lt;script&gt;的开放策略 ，前端从json解析器变成JavaScript直译器，需要目标服务器配合calback函数。:+1:支持老式浏览器，:-1:只支持get请求,需要客户端服务端同时改变 Nginx反向代理：挺好的 方案3步骤：在docker-compose.yml 12345678910111213user nginx:~~~~~server&#123; listen 80; server_name 192.168.75.128; location /&#123; add_header Access-Control-Allow-Origin *; add_header Access-Control-Headers X-Requested-With; add_header Access-Control-Methods GET,POST,OPTIONS; 数据卷 &#125;&#125;]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>oAth2</tag>
        <tag>sso</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[oAth2(一)]]></title>
    <url>%2F2019%2F08%2F08%2FoAuth2%E5%89%8D%E8%A8%80%2F</url>
    <content type="text"><![CDATA[oAth2背景传统登录状态出现问题 多个服务分别部署，需要分别登录 第三方应用介入对用户登录信息的需求 用户无法限制第三方应用在某个微服务中的授权范围和使用期限 用户修改登录信息对第三方的应用影响 第三方应用的破解会导致用户密码泄露 OAth2架构模式 交互过程 开放平台交互模型 资源拥有者：用户 客户端：APP 服务提供方： 认证服务器 资源服务器 步骤： 用户 - 输入账号密码 -&gt; 腾讯提供的开放平台（提供：给谁授权、授权范围) 腾讯提供的开放平台登录成功 - 有道云笔记 授权码-&gt; 有道云笔记根据授权码访问腾讯 认证服务器去拿 访问令牌，用 访问令牌 去腾讯的 资源服务器， 资源服务器 根据令牌上的（授权人 &amp; 授权范围 ) 提供相应的资源：（用户昵称、头像、性别）。 有道云笔记根据获取的信息先注册个账号（填入相关信息 ： 不过你还要再完善相关信息：手机这些） 总结：开放平台只是获取部分信息，简化一定的注册流程 遵循OAuth2.0协议 即接口提供认证和授权标准 例如：接口JAP @Table @Column @Id Hibernate实现 用Spring Security 实现 令牌的访问与刷新原始令牌风险url：http://www.sdfsdf/usr/token=123 toekn被人发现，被爬虫一直刷 token一直在，别人抓包，就能抓到令牌，数据被别人拿去。 解决方案： 令牌刷新，用旧令牌获取新令牌：传入refresh_token 、 client_id 认证服务器通过会返回新的Access Token 要求： Refresh Token 保存在客户端服务器 client_secret机制：client_id(客户端) &lt;-&gt; client_secret（服务端）,在申请client_id会一起把client_secret分配给客户端，client_secret ##妥善保管在服务器##,刷新Access Token ，需要验证client_secret。 url变成： url:http://www.sdfsdf//refresh?refresh_token=&amp;client_id=&amp;client_secret= 所以第三方应用提供： appId = client_id appSecret = client_secret 客户端授权模式 简化模式 纯静态页面应用，APP，小程序，HTML5，第三方天气，个人博客，只有前端js控制权。 授权码模式 密码模式 客户端模式 总结： +访问令牌+ access Toekn + Refresh Toekn]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>oAth2</tag>
        <tag>sso</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java网络编程]]></title>
    <url>%2F2019%2F07%2F28%2FNetty%2F</url>
    <content type="text"><![CDATA[java网络编程BIO123456789101112131415161718psvm&#123; ServerSocket ss = new ServerSocket(); ss.bind(new InetSocketAddress("127.0.0.1"),8888); while(true)&#123; Socket s = ss.accept(); new Thread(() -&gt;&#123; heandle(s); &#125;).start(); &#125;&#125;static void handle(Socket s)&#123; try&#123; byte[] bytes = new byte[1024]; int len = s.getInputStream().read(bytes); s.getOutputStream().write(bytes,0,len); &#125;catch &#123;bala&#125;&#125; graph RL ss --bind --> s subgraph server s(s:127.0.0.1:8888) end subgraph listen s --accept--> thread1 s --accept--> thread2 s --accept-->thread3 end BIO会出现的问题 ss.accept()内的线程会 read write 解决方案：轮询 NIO-single Thread（NewNon-Blocking)说明：大管家selector轮询：如果有客户端连接，就处理（单线程）压力很大 1234567891011121314151617181920psvm&#123; ServerSocketChannel ssc = .open(); ssc.socket().bind (~~~); ssc.configureBlocking(false); Selector selector = Selector.open(); ssc.register(selector ,~); while(true)&#123; selector.select(); //轮询选择到的请求 -&gt; 也是阻塞 Set&lt;SelectionKey&gt; key -&gt; selector.selectedKeys(); //事件发生 把当前事件设个key //遍历SelectinKey 把得到的key remove handle(key) &#125;&#125;void handle()&#123; ServerSocketChannel ssc = key.channel(); SocketChannel sc = ssc.accept(); //阻塞 -&gt; false sc.register( //设一个key) &#125; graph RL boy(大管家) --注册--> accept1 boy(大管家) --注册--> accept2 subgraph list key_one key_two end subgraph 插座 accept1 --register--- key_one accept2 --register--- key_two 等待 end AIO实现了异步非阻塞IOAIO取消了对Selector注册通道的轮询 采用hock函数将read 、write 、accept 3个不同模块分别交付给os操作。]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>Netty</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[标签测试]]></title>
    <url>%2F2019%2F07%2F28%2F%E6%A0%87%E7%AD%BE%E6%B5%8B%E8%AF%95%2F</url>
    <content type="text"><![CDATA[随便写写]]></content>
      <tags>
        <tag>Testing</tag>
        <tag>Another Tag</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo第二次试验]]></title>
    <url>%2F2019%2F07%2F28%2Fhexo%E7%AC%AC%E4%BA%8C%E6%AC%A1%E8%AF%95%E9%AA%8C%2F</url>
    <content type="text"><![CDATA[sdfsdfsd]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>博客</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[打 打一个大菠萝呀]]></title>
    <url>%2F2019%2F07%2F27%2F%E6%89%93-%E6%89%93%E4%B8%80%E4%B8%AA%E5%A4%A7%E8%8F%A0%E8%90%9D%E5%91%80%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F07%2F27%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
